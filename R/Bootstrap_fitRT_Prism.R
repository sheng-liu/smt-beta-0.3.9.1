#### Fitting 1-CDF of Bootstrapped residence time data with exponential decay using modified formula
#### Wu Lab, Johns Hopkins University
#### Author: Xiaona Tang
#### Date: Jun 10, 2020

## Bootstrapping residence time data and multi-component exponential decay fitting-methods
##
###############################################################################
##' @name Bootstrap_fitRT_Prism
##' @aliases fitRT_Boot_2comp_Prism
##' @title Fitting 1-CDF of Bootstrapped residence time data with exponential decay using modified formula
##' @rdname Bootstrap_fitRT_Prism-methods
##' @docType methods
##' @description Fit 1-CDF of from bootstrapped data sets with multi-component exponential decay can derive average unbinding rate (k off) 
##' and estimate the standard deviation.
##' 
##'
##' @usage
##'
##' calculate_1_CDF(trackll=trackll,x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),t.interval=0.5,output=FALSE,plot_linear=TRUE)
##' 
##' calculate_1_CDF_multiple(trackll=c(trackll1,trackll2),x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),
##' t.interval=0.5,x.max.linear=NULL,output=FALSE,plot_linear=FALSE,plotCI=TRUE)
##' 
##' BootData=Boot_1_CDF(trackll=trackll,t.interval=0.25,R=100,output=FALSE,plot=TRUE,x.max=100,y.min=0.0001)
##' 
##' fitRT_Boot_2comp_Prism(BootData,t.interval=0.25,x.max=100,y.min=0.0001,output=FALSE,plateau=FALSE,k_ns=FALSE)
##' 
##' 
##'
##' @param trackll trajectory list generated by createTrackll() and processing. if NULL, user will be prompted to enter the trackll name.
##' @param x.max The maximum range of X axis for log-log scaled plot, i.e. time, for the output plot. Default 100 sec.
##' @param y.min The minium value of Y axis in log scaled plot.
##' @param filter Filter the tracks by step/frame number (length). Only tracks pass through filter will be selected.
##' @param t.interval time interval for image aquisition. Default 0.5 sec.
##' @param output A Logical indicate if output should be generated. See Values for detail.
##' @param plateau A Logical indicate whether to include a plateau in the fitting equation, if FALSE, will set plateau as 0.
##' @param k.ns Logical indicate, a single numeric or a numeric range used to control fitting.
##' @param plotType type of plot for 1-CDF, "l" for line plot, "p" for point plot.
##' @return
##' \itemize{
##' \item{csv:} 
##' The fitting functions output the fitting result of original and all bootstrapped data sets.
##' 
##' \item{Plot:} fitting of original and bootstrapped datasets.
##' }
##' @details 
##' 
##' fitting 1-CDF of all bootstrapped data sets with multi-component exponential decay can derive average unbinding rate (k off) 
##' and estimate the standard deviation.
##' 
##' 1-CDF is fitted with modified 2-component exponential decay formula in case of x>0 when 1-CDF=1.
##' Plateau + (Y0-Plateau)*alpha*exp(-k_s*(t)) + (Y0-Plateau)*(1-alpha)*exp(-k_ns*(t))
##'
##' @examples
##'
##' # Generate trackll, and process, 
##' # e.g. mask region of interest, merge tracks from multiple files.
##' folder1=system.file("extdata","HSF",package="sojourner")
##' trackll1=createTrackll(folder1,input=2, cores = 2)
##' trackll1=maskTracks(folder1,trackll1)
##' trackll1=mergeTracks(folder1,trackll1)
##' 
##' folder2=system.file("extdata","HSF_2",package="sojourner")
##' trackll2=createTrackll(folder2,input=2, cores = 2)
##' trackll2=maskTracks(folder2,trackll2)
##' trackll2=mergeTracks(folder2,trackll2)
##'
##' # Plot and output the survival curve,
##' calculate_1_CDF(trackll=trackll1,x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),
##' t.interval=0.5,output=FALSE,plot_linear=TRUE)
##' calculate_1_CDF_multiple(trackll=c(trackll1,trackll2),x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),
##' t.interval=0.5,x.max.linear=NULL,output=FALSE,plot_linear=FALSE,plotCI=TRUE)
##' 
##' # Generate boot strapped data
##' BootData=Boot_1_CDF(trackll=trackll,t.interval=0.25,R=100,output=FALSE,
##' plot=TRUE,x.max=100,y.min=0.0001)
##' 
##' # Fit boot strapped data
##' fitRT_Boot_2comp_Prism(BootData,t.interval=0.25,x.max=100,y.min=0.0001,
##'                                  output=FALSE,plateau=FALSE,k_ns=FALSE,plot.fit = TRUE)
##' 
##' 
##' @importFrom mltools empirical_cdf 
##' @export fitRT_Boot_2comp_Prism
##' 
#####################################################################################
#####################################################################################

################################################################################

########################################################################################
## Function for 2 or 3-component exponential decay fitting
twoCompFitRT_Prism=function(t,P,t.interval,start=list(k_s=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),Plateau=c(0,1),Y0=c(1,10)),maxiter.search=2e3,plateau=FALSE,k_ns=FALSE){
  
  ## Equation for two component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p2 =function(t,alpha,k_s,k_ns,Plateau,Y0){
      Plateau + (Y0-Plateau)*alpha*exp(-k_s*(t)) + (Y0-Plateau)*(1-alpha)*exp(-k_ns*(t))}
  
  ## First fit using nls2
  k.search.tcfit=nls2::nls2(P ~ p2(t,alpha,k_s,k_ns,Plateau,Y0),start=data.frame(start),
                            # algorithm="brute-force",
                            algorithm="random-search",
                            control = nls.control(maxiter = maxiter.search))
  
  ## Local optimization using nlsLM.
  if(plateau){
    if(k_ns == FALSE){
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns,Plateau,Y0),
                              start=coef(k.search.tcfit),
                              lower=c(0,0,0,0,1),
                              upper=c(Inf,Inf,1,1,10)) 
    }
    ## Use a range for k_ns given by user
    else if (length(k_ns)==2){
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns,Plateau,Y0),
                              start=coef(k.search.tcfit),
                              lower=c(0,k_ns[1],0,0,1),
                              upper=c(Inf,k_ns[2],1,1,10))
    }
    ## Use a fixex k_ns value given by user.
    else{
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns,Plateau,Y0),
                              start=coef(k.search.tcfit),
                              lower=c(0,k_ns,0,0,1),
                              upper=c(Inf,k_ns,1,1,10))
    }
  }else{
    if(k_ns == FALSE){
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns,Plateau,Y0),
                              start=coef(k.search.tcfit),
                              lower=c(0,0,0,0,1),
                              upper=c(Inf,Inf,1,0,10)) 
    }
    ## Use a range for k_ns given by user
    else if (length(k_ns)==2){
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns,Plateau,Y0),
                              start=coef(k.search.tcfit),
                              lower=c(0,k_ns[1],0,0,1),
                              upper=c(Inf,k_ns[2],1,0,10))
    }
    ## Use a fixex k_ns value given by user.
    else{
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns,Plateau,Y0),
                              start=coef(k.search.tcfit),
                              lower=c(0,k_ns,0,0,1),
                              upper=c(Inf,k_ns,1,0,10))
    }
  }
  
  
  return(tcfit)
}


twoCompFitRT_weighted=function(t,P,t.interval,start=list(k_s=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1)),
                      weighting=TRUE,maxiter.search=2e3){
  
  ## Equation for two component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p2 =function(t,alpha,k_s,k_ns){
        alpha*exp(-k_s*(t)) + (1-alpha)*exp(-k_ns*(t))}
    
    ## First fit using nls2
    k.search.tcfit=nls2::nls2(P ~ p2(t,alpha,k_s,k_ns),start=data.frame(start),
                              # algorithm="brute-force",
                              algorithm="random-search",
                              control = nls.control(maxiter = maxiter.search))
    
    ## Local optimization using nlsLM.
    
    if (weighting){
      #data=as.data.frame(cbind(P,t))
      data=data.frame(P,t)
      #weight=1/(P+0.000001)
      #weight=1/(P+0.00000001)^2
      #weight=1/abs(log10(P+0.00000001))
      weight=1/P
      weight[which(weight==Inf)]<-max(weight[which(weight!=Inf)])
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns),data = data,
                              start=coef(k.search.tcfit),
                              lower=c(0,0,0),
                              upper=c(Inf,Inf,1),weights = weight)
    }else{
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns),
                              start=coef(k.search.tcfit),
                              lower=c(0,0,0),
                              upper=c(Inf,Inf,1)) 
    }
        
      

   return(tcfit)
}

## Three component fitting
threeCompFitRT=function(t,P,t.interval,start=list(k_s=c(1/600,1/t.interval),k_m=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),beta=c(1e-3,1)),maxiter.search=2e3,k_ns=FALSE){
  
  ## Equation for three component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p3 =function(t,alpha,beta,k_s,k_m,k_ns){
    alpha*exp(-k_s*(t)) + beta*exp(-k_m*(t)) + (1-alpha-beta)*exp(-k_ns*(t))}
  
  ## First fit using nls2
  k.search.thcfit=nls2::nls2(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),start=data.frame(start),
                             # algorithm="brute-force",
                             algorithm="random-search",
                             control = nls.control(maxiter = maxiter.search))
  
  ## Local optimization using nlsLM.
  
  if(k_ns == FALSE){
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),
                             start=coef(k.search.thcfit),
                             lower=c(0,0,0,0,0),
                             upper=c(Inf,Inf,Inf,1,1))
  }else if (length(k_ns)==2){
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),
                             start=coef(k.search.thcfit),
                             lower=c(0,0,k_ns[1],0,0),
                             upper=c(k_ns[2],k_ns[2],k_ns[2],1,1))
  }
  ## Use a fixex k_ns value given by user.
  else{
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),
                             start=coef(k.search.thcfit),
                             lower=c(0,0,k_ns,0,0),
                             upper=c(k_ns,k_ns,k_ns,1,1))
  }
  
  return(thcfit)
}


threeCompFitRT_weighted=function(t,P,t.interval,start=list(k_s=c(1/600,1/t.interval),k_m=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),beta=c(1e-3,1)),
                        weighting=TRUE,maxiter.search=2e3,k_ns=FALSE){
  
  ## Equation for three component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p3 =function(t,alpha,beta,k_s,k_m,k_ns){
    alpha*exp(-k_s*(t)) + beta*exp(-k_m*(t)) + (1-alpha-beta)*exp(-k_ns*(t))}
  
  ## First fit using nls2
  k.search.thcfit=nls2::nls2(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),start=data.frame(start),
                            # algorithm="brute-force",
                            algorithm="random-search",
                            control = nls.control(maxiter = maxiter.search))
  
  ## Local optimization using nlsLM.
  if(weighting){
    data=as.data.frame(cbind(P,t))
    #weight=1/(P+0.000001)
    #weight=1/(P+0.00000001)^2
    #weight=1/abs(log10(P+0.00000001))
    weight=1/P
    weight[which(weight==Inf)]<-max(weight[which(weight!=Inf)])
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),data=data,
                             start=coef(k.search.thcfit),
                             lower=c(0,0,0,0,0),
                             upper=c(Inf,Inf,Inf,1,1),weights = weight)
  }else{
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),
                             start=coef(k.search.thcfit),
                             lower=c(0,0,0,0,0),
                             upper=c(Inf,Inf,Inf,1,1))
  }
  
  return(thcfit)
}


################################################################################
# Helper/evaluation functions. Use whichever are necessary.
concat.text=function(x,y,txt,col) { 
  thisx<-x 
  for(txtstr in seq_along(txt)) { 
    text(thisx,y,txt[txtstr],col=col[txtstr],adj=0) 
    thisx<-10^(log10(thisx)+strwidth(txt[txtstr]))
  } 
} 

twoComponentPrediction_Prism = function(t, alpha, k_s, k_ns,Plateau,Y0){
    return(Plateau + (Y0-Plateau)*alpha*exp(-k_s*t)+(Y0-Plateau)*(1-alpha)*exp(-k_ns*t))
}

threeComponentPrediction = function(t, alpha, beta, k_s, k_m, k_ns){
  return(alpha*exp(-k_s*t)+beta*exp(-k_m*t)+(1-alpha-beta)*exp(-k_ns*t))
}

residualPlot = function(t, P, P_pred){
  residuals = P-P_pred
  #plot(t, residuals, ylab= "Residuals", xlab ="t", type="l")
  plot(t, residuals, ylab= "Residuals", xlab =" ", type="p",cex=0.8,
       las=1,bty="n",axes = FALSE)
  axis(1, at=seq(floor(min(t)), ceiling(max(t)), 5))
  axis(2, at=seq(floor(min(residuals)), ceiling(max(residuals)), 0.005),las=1)
  title(xlab="Time (s)",cex.lab=1,line=-1)
  abline(h = 0)
}

RSS = function(P, P_pred){
  return(sum((P-P_pred)^2))
}

# params = 3, for two comp
# params = 5, for three comp
AIC = function(P, P_pred, params){
  n = length(P)
  k = params
  df = n-k
  return(2*df+n*log(RSS(P, P_pred)))
}

# params = 3, for two comp
# params = 5, for three comp
BIC = function(P, P_pred, params){
  n = length(P)
  k = params
  df = n-k
  return(log(n)*df+n*log(RSS(P, P_pred)))
}

################################################################################
## Generate bootstrapped data of 1-CDF:


Boot_1_CDF<-function(trackll=trackll,t.interval=0.25,R=100,output=FALSE,plot=TRUE,x.max=100,y.min=0.0001){
  
  trajLength<-sapply(trackll[[1]],function(x){(x$Frame[dim(x)[1]]-x$Frame[1]+1)*t.interval})
  t<-seq(t.interval,max(trajLength),by=t.interval)
  t.plot<-seq(t.interval,x.max,by=t.interval)
  CDF<-mltools::empirical_cdf(trajLength,ubounds=seq(t.interval, max(trajLength), by=t.interval))
  P<-(1-(CDF$CDF))
  
  name=names(trackll)
  
  resamples <- lapply(1:R, function(i) sample(trajLength, replace = T))
  CDF.resamples<-lapply(resamples,function(x)
  {mltools::empirical_cdf(x,ubounds=seq(t.interval, max(x), by=t.interval))})
  P.resamples<-lapply(CDF.resamples,function(x)(1-(x$CDF)))
  
  
  if(plot){
    par(mar = c(5,6,4,2) + 0.1)
    plot(t.plot,P[1:length(t.plot)],main="Bootstrapped data",xlab="Time (s)",ylab=" ",
         cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
         bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
    title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
    at.y <- outer(1:9, 10^(log10(y.min):0))
    lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
    lab.y[1,] <- formatC(lab.y[1,],digits=0)
    axis(2, at=at.y, labels=lab.y, las=1)
    at.x <- outer(1:9, 10^(-1:log10(x.max)))
    lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
    axis(1, at=at.x, labels=lab.x, las=1)
    
    ##color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
    color=rainbow(2*R)
    col=sample(color, R)
    
    for (i in 1:R){
      lines(t.plot,P.resamples[[i]][1:length(t.plot)],col=col[i],lwd=1.5)
    }
    
    
    points(t.plot,P[1:length(t.plot)],pch=20,cex=1)
    
    legend("bottomleft",legend = c(names(trackll),paste("n = ",length(trackll[[1]]),sep=""),
                                   "Original data"," "),
           pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black","black","red"),
           col=c("black","black","black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
    temp <- legend("bottomleft", legend = c(" ", " "," "," "),
                   pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,
                   col=c("black","black","black","red"),
                   text.width = 10^(strwidth("Bootstrap iterations: 100")),
                   y.intersp = 0.8,x.intersp = 0.5,bty="n",cex=1)
    
    ctext<-c('B','o','o','t','s','t','r','a','p ','i','t','e','r','a','t','i','o','n','s',': ',R)
    par(font=2)
    #concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=sample(col,length(ctext))) 
    concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=rainbow(length(ctext))) 
  }
  
  ## Output original 1-CDF along with resampled 1-CDF
  P.output=append(list(P),P.resamples)
  t.output=seq(t.interval,max(sapply(P.output,function(x)(length(x)))),by=t.interval)
  tP.output=append(list(t.output),P.output)
  tP.output=plyr::ldply(tP.output, rbind)
  tP.output[is.na(tP.output)] <- 0
  tP.output=as.data.frame(t(tP.output))
  colnames(tP.output)<-c("Time (s)","Oritinal",paste("Resampled_",seq(1:R)))
  if(output){
    filename<-paste("1-CDF-Bootstrap-",names(trackll),"-",format(Sys.time(),"%Y%m%d_%H%M%S"),".csv",sep="")
    write.table(tP.output, filename  , append= F, sep=',', row.names = F)
  }
  name=names(trackll)
  return(invisible(list("Time"=t.output,"1-CDF"=P.output,"Name"=name,"n"=length(trackll[[1]]))))
}


################################################################################
## 2 or 3-component exponential decay fitting of original and bootstrapped data

fitRT_Boot_2comp_Prism<-function(BootData,t.interval=0.25,x.max=100,y.min=0.0001,output=FALSE,plateau=FALSE,k_ns=FALSE){
  ## Output plots into a PDF file
  pdf(paste("Bootstrapped data 2-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".pdf",sep=""),width=11,height=8.5)
  R=length(BootData$`1-CDF`)
  P=BootData$`1-CDF`
  ## Plot original 1-CDF curve as dots in log scale x, y axis
  t.plot<-seq(t.interval,x.max,by=t.interval)
  par(mar = c(5,6,4,2) + 0.1)
  plot(t.plot,P[[1]][1:length(t.plot)],main="Bootstrapped data",xlab="Time (s)",ylab=" ",
       cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
       bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
  title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
  at.y <- outer(1:9, 10^(log10(y.min):0))
  lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
  lab.y[1,] <- formatC(lab.y[1,],digits=0)
  axis(2, at=at.y, labels=lab.y, las=1)
  at.x <- outer(1:9, 10^(-1:log10(x.max)))
  lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
  axis(1, at=at.x, labels=lab.x, las=1)
  
  ## Plot bootstrapped 1-CDF curves as lines in random color
  ##color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
  
  color=rainbow(2*R)
  col=sample(color, R)
  
  for (i in 2:R){
    lines(t.plot,P[[i]][1:length(t.plot)],col=col[i],lwd=1.5)
  }
  
  ## Add original 1-CDF curve as dots on top
  points(t.plot,P[[1]][1:length(t.plot)],pch=20,cex=1)
  
  ## Legend
  legend("bottomleft",legend = c(BootData$Name,paste("n = ",BootData$n,sep=""),
                                 "Original data"," "),
         pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black","black","red"),
         col=c("black","black","black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
  temp <- legend("bottomleft", legend = c(" ", " "," "," "),
                 pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,
                 col=c("black","black","black","red"),
                 text.width = 10^(strwidth("Bootstrap iterations: 100")),
                 y.intersp = 0.8,x.intersp = 0.5,bty="n",cex=1)
  
  ctext<-c('B','o','o','t','s','t','r','a','p ','i','t','e','r','a','t','i','o','n','s',': ',R-1)
  par(font=2)
  
  concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=rainbow(length(ctext))) 
  
  cat("\nStart fitting bootstrapped samples...\n")
  
  ## fit bootstrapped data
  ## 2-component fitting
  boot.2.fitRT=c()
  
  par(mfrow=c(2,2),bg="white",fg="black")
  for (i in 1:R){
    
    if (i==1){
      cat("\r","Original data","         2-component fitting")
    }else{
      cat("\r","Bootstrapped data # ",i-1,"      2-component fitting")
    }  
    
    ## Plot the data to be fitted in log-log scale
    par(mar = c(5,6,4,2) + 0.1)
    if (i==1){
      plot(t.plot,P[[i]][1:length(t.plot)],main="Original data",xlab="Time (s)",ylab=" ",
           cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
           bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
    }
    else{
      plot(t.plot,P[[i]][1:length(t.plot)],main=paste0("Bootstrapped data # ",i-1),xlab="Time (s)",ylab=" ",
           cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
           bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
    }
    
    title(ylab="Survival probability (1-CDF)",cex.lab=1.1,line=3.6)
    axis(2, at=at.y, labels=lab.y, las=1)
    axis(1, at=at.x, labels=lab.x, las=1)
    
    ## Generate X values of data points for fitting
    if(length(which(P[[i]] == 1))>=2){
      t.fit<-seq(t.interval*length(which(P[[i]] == 1)),t.interval*length(P[[i]]),by=t.interval)
    }else{
      t.fit<-seq(t.interval,t.interval*length(P[[i]]),by=t.interval)
    }
    
    ## Generate Y values of data points for fitting
    ## Remove multiple "1" of P values, leaving only one "1" value.
    ## The rest P values will be used for fitting.  
    if(length(which(P[[i]] == 1))>=2){
      P.fit<-P[[i]][-(1:(length(which(P[[i]] == 1))-1))]
    } else{
      P.fit<-P[[i]]
    }
    
    # t minimum correction
    # t.fit.shift = t.fit - min(t.fit)
    
    result = NULL
    attempt = 0
    maximum_attempts = 50
    while( (is.null(result) && attempt <= maximum_attempts) || 
           coef(result)['alpha']<0 ){
        #cat(paste0("\nattemp=",attempt))
        try(
            result<-twoCompFitRT_Prism(t=t.fit,P=P.fit,t.interval,start=list(k_s=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),Plateau=c(0,1),Y0=c(1,10)),
                                       maxiter.search=1e3,plateau=plateau,
                                       k_ns=k_ns),
            silent = TRUE
        )
        #cat("\n")
        #print(coef(result))
        #cat(paste0("\nalpha+beta=",as.numeric((coef(result)['alpha'] + coef(result)['beta']))))
        attempt = attempt + 1
    }
    
    
    if(!is.null(result)){
        result=coef(result)[c(3,1,2,4,5)]
        if (as.numeric(result['k_s'])>as.numeric(result['k_ns'])){
            result=result[c(1,3,2,4,5)]
            result[1]=1-as.numeric(result[1])
            names(result)=c("alpha","k_s","k_ns","Plateau","Y0")
        }
    }

    
    # Calculate predicted/expected P from the fit
    P_pred = twoComponentPrediction_Prism(t.fit, result['alpha'], result['k_s'], result['k_ns'],result['Plateau'],result['Y0'])
    
    ## Calculate the fitting errors
    rss=RSS(P.fit, P_pred)
    aic=AIC(P.fit, P_pred, 3)
    bic=BIC(P.fit, P_pred, 3)
    #result=c(result[2:4],rss,aic,bic)
    result=c(result,rss,aic,bic)
    names(result)[6:8]=c("RSS","AIC","BIC")
    
    boot.2.fitRT=rbind(boot.2.fitRT,result)
    
    # Plot fitted curve
    p2_model = function(x){
        result['Plateau'] + (result['Y0']-result['Plateau'])*result['alpha']*exp(-result['k_s']*x) + (result['Y0']-result['Plateau'])*(1- result['alpha'])*exp(-result['k_ns']*x)
    }
    curve(p2_model,add=T,col="red",lwd=2)
    
    ## Print parameters on the plot
    result.text=c(expression(italic(P(t) == alpha*e^-k[s]*''^t+(1-alpha)*e^-k[ns]*''^t)),
                  as.expression(bquote(italic('k'['s']==.(result['k_s'])))),
                  as.expression(bquote(italic('k'['ns']==.(result['k_ns'])))),
                  as.expression(bquote(italic(alpha==.(result['alpha'])))),
                  "  ",
                  as.expression(bquote(italic(Plateau==.(result['Plateau'])))),
                  as.expression(bquote(italic(Y0==.(result['Y0'])))),
                  as.expression(bquote(italic('RSS'==.(result['RSS'])))),
                  as.expression(bquote(italic('AIC'==.(result['AIC'])))),
                  as.expression(bquote(italic('BIC'==.(result['BIC'])))),
                  " "
    )
    legend("left",legend=result.text,pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
    par(font=1)
    legend("topright",legend = c("Data      ","Fit      "),
           pch=c(20,NA),lty=c(NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black"),
           col=c("black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
    
    flush.console()
  }
  
  rownames(boot.2.fitRT)<-c(0:(R-1))
  
  boot.2.fitRT.df=as.data.frame(boot.2.fitRT)
  boot.2.fitRT.filter=boot.2.fitRT.df[which(boot.2.fitRT.df[,2]>0),]
  
  ## Plot RSS
  options(scipen=10)
  plot(rownames(boot.2.fitRT.filter),boot.2.fitRT.filter$RSS,type='p',main="RSS of 2-component fitting",
       xlab = "Data #", ylab = "RSS",las=1, cex.axis=0.8,xaxt="n")
  axis(1, at = seq(0, (R-1), by = 5), las=1)
  
  ## Plot histogram for kstable
  hist<-hist(as.numeric(boot.2.fitRT.filter[,2]),main = "Histogram of 2 component fitting", 
       xlab = as.expression(bquote(italic('k'['stable']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  legend_text=c(as.expression(bquote('Mean of k'['stable'] ==.(mean(as.numeric(boot.2.fitRT.filter[,2]))))),
                as.expression(bquote('SD of k'['stable'] ==.(sd(as.numeric(boot.2.fitRT.filter[,2]))))),
                as.expression(bquote('n'==.(length(boot.2.fitRT.filter[,2])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  
  ## Plot histogram for Fstable
  hist<-hist(as.numeric(boot.2.fitRT.filter[,1]),main = "Histogram of 2 component fitting", 
       xlab = as.expression(bquote(italic('F'['stable']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  legend_text=c(as.expression(bquote('Mean of F'['stable'] ==.(mean(as.numeric(boot.2.fitRT.filter[,1]))))),
                as.expression(bquote('SD of F'['stable'] ==.(sd(as.numeric(boot.2.fitRT.filter[,1]))))),
                as.expression(bquote('n'==.(length(boot.2.fitRT.filter[,1])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  
  ## Plot histogram for ktransient
  hist<-hist(as.numeric(boot.2.fitRT.filter[,3]),main = "Histogram of 2 component fitting", 
             xlab = as.expression(bquote(italic('k'['transient']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  legend_text=c(as.expression(bquote('Mean of k'['transient'] ==.(mean(as.numeric(boot.2.fitRT.filter[,3]))))),
                as.expression(bquote('SD of k'['transient'] ==.(sd(as.numeric(boot.2.fitRT.filter[,3]))))),
                as.expression(bquote('n'==.(length(boot.2.fitRT.filter[,3])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  
  dev.off()
  
  if(output){
    boot.2.fitRT.filter.2 <- apply(boot.2.fitRT.filter,2,as.numeric)
    filename<-paste("Bootstrapped data 2-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".csv",sep="")
    write.table(boot.2.fitRT.filter.2, filename, append= F, sep=",",  col.names=NA,row.names = row.names(boot.2.fitRT.filter))
  }
  
  cat("\n\nPDF output in working directory\n\n")
  return(boot.2.fitRT.filter)

}


