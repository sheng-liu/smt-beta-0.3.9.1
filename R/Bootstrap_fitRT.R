#### Fitting 1-CDF of Bootstrapped residence time data with exponential decay
#### Wu Lab, Johns Hopkins University
#### Author: Xiaona Tang, Sun Jay Yoo
#### Date: Sep 20, 2019

## Bootstrapping residence time data and multi-component exponential decay fitting-methods
##
###############################################################################
##' @name Bootstrap_fitRT
##' @aliases Bootstrap_fitRT calculate_1_CDF calculate_1_CDF_multiple Boot_1_CDF fitRT_Boot_1comp fitRT_Boot_2comp fitRT_Boot_3comp
##'  fitRT_Boot_2and3comp
##' @title Fitting 1-CDF of Bootstrapped residence time data with exponential decay
##' @rdname Bootstrap_fitRT-methods
##' @docType methods
##' @description Calculate/Compare Residence time/Survival Curve of single/multiple trackll, 
##' with upper and lower bound of 95 percent conficence interval.
##' 
##' Generate bootstrapped data sets (resampling) of residence times, fitting 1-CDF of all bootstrapped
##' data sets with multi-component exponential decay can derive average unbinding rate (k off) 
##' and estimate the standard deviation.
##' 
##'
##' @usage
##'
##' calculate_1_CDF(trackll=trackll,x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),t.interval=0.5,output=FALSE,plot_linear=TRUE)
##' 
##' calculate_1_CDF_multiple(trackll=c(trackll1,trackll2),x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),
##' t.interval=0.5,x.max.linear=NULL,output=FALSE,plot_linear=FALSE,plotCI=TRUE)
##' 
##' BootData=Boot_1_CDF(trackll=trackll,t.interval=0.25,R=100,output=FALSE,plot=TRUE,x.max=100,y.min=0.0001)
##' 
##' fitRT_Boot_1comp(BootData,t.interval=0.25,x.max=100,y.min=0.0001,output=FALSE,plot.fit = TRUE)
##' 
##' fitRT_Boot_2comp(BootData,t.interval=0.25,x.max=100,y.min=0.0001,output=FALSE,k_ns=FALSE)
##' 
##' fitRT_Boot_3comp(BootData,t.interval=0.25,x.max=100,y.min=0.0001,output=FALSE,k_ns=FALSE)
##' 
##' fitRT_Boot_2and3comp(BootData,t.interval=0.25,x.max=100,y.min=0.0001,
##'                                  cutoff=FALSE,weighting=TRUE,output=FALSE,k_ns=FALSE,plot.fit = TRUE)
##' 
##'
##' @param trackll trajectory list generated by createTrackll() and processing. if NULL, user will be prompted to enter the trackll name.
##' @param x.max The maximum range of X axis for log-log scaled plot, i.e. time, for the output plot. Default 100 sec.
##' @param y.min The minium value of Y axis in log scaled plot.
##' @param filter Filter the tracks by step/frame number (length). Only tracks pass through filter will be selected.
##' @param t.interval time interval for image aquisition. Default 0.5 sec.
##' @param output A Logical indicate if output should be generated. See Values for detail.
##' @param plot_linear An Logical indicate if also plot in linear scale. log-log scaled plot is default.
##' @param x.max.linear The maximum range of X axis for linear scaled plot, if not specified, will be generated based on data.
##' @param plotCI A Logical indicate if to plot upper and lower bound of 95 percent conficence interval.
##' @param R number of resampling times for bootstrapping, default is 100.
##' @param plot A Logical indicate if to plot for Boot_1_CDF.
##' @param plot.fit An Logical indicate if to plot the fitting result of all bootstrapped data set. If False, only 3 rows of fitting will be plotted.
##' @param cutoff A value of X axis (time) to cutoff when fitting. Data points larger than cutoff will not be used in fitting.
##' @param weighting A Logical indicate if the fitting should weight on the tail of 1-CDF curve, the weighting equation is 1/Y.
##' @param k.ns Logical indicate or numeric used to control fitting.
##' @param plotType type of plot for 1-CDF, "l" for line plot, "p" for point plot.
##' @return
##' \itemize{
##' \item{csv:} calculate_1_CDF outputs 1-CDF of track lengths of a single trackll and time intervals output in .csv format, when output = TRUE.
##' calculate_1_CDF_multiple outputs 1-CDF of track lenghts of multiple trackll and time intervals output in .csv format, when output = TRUE.
##' Boot_1_CDF outputs 1-CDF of track length of original and bootstrapped data of a single trackll.
##' The fitting functions output the fitting result of original and all bootstrapped data sets.
##' 
##' \item{Plot:} 1-CDF of track lengths of each input trackll will be plotted together in one plot.
##' }
##' @details calculate_1_CDF calculate Survival Curve of a trackll, with upper and lower bound of 
##' 95 percent conficence interval. The survival curve/probability is calculated as 1-CDF of the length of tracks/trajectories.
##' 
##' calculate_1_CDF_multiple compare the 1-CDF of multiple tracklls.
##' 
##' Boot_1_CDF generates bootstrapped data sets (resampling) of residence times, and plot
##' 1-CDF curves of original and bootstrapped data sets.
##' 
##' fitting 1-CDF of all bootstrapped data sets with multi-component exponential decay can derive average unbinding rate (k off) 
##' and estimate the standard deviation.
##' 
##' The maximum time range to be plotted can be set using x.max, this will not change the curve/probabiltiy, 
##' which is determined by all track information in the trackll. 
##'
##' @examples
##'
##' # Generate trackll, and process, 
##' # e.g. mask region of interest, merge tracks from multiple files.
##' folder1=system.file("extdata","HSF",package="sojourner")
##' trackll1=createTrackll(folder1,input=2, cores = 2)
##' trackll1=maskTracks(folder1,trackll1)
##' trackll1=mergeTracks(folder1,trackll1)
##' 
##' folder2=system.file("extdata","HSF_2",package="sojourner")
##' trackll2=createTrackll(folder2,input=2, cores = 2)
##' trackll2=maskTracks(folder2,trackll2)
##' trackll2=mergeTracks(folder2,trackll2)
##'
##' # Plot and output the survival curve,
##' calculate_1_CDF(trackll=trackll1,x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),
##' t.interval=0.5,output=FALSE,plot_linear=TRUE)
##' calculate_1_CDF_multiple(trackll=c(trackll1,trackll2),x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),
##' t.interval=0.5,x.max.linear=NULL,output=FALSE,plot_linear=FALSE,plotCI=TRUE)
##' 
##' # Generate boot strapped data
##' BootData=Boot_1_CDF(trackll=trackll,t.interval=0.25,R=100,output=FALSE,
##' plot=TRUE,x.max=100,y.min=0.0001)
##' 
##' # Fit boot strapped data
##' fitRT_Boot_2and3comp(BootData,t.interval=0.25,x.max=100,y.min=0.0001,
##'                                  cutoff=FALSE,weighting=TRUE,output=FALSE,k_ns=FALSE,plot.fit = TRUE)
##' 
##' 
##' @importFrom mltools empirical_cdf 
##' @export calculate_1_CDF
##' @export calculate_1_CDF_multiple
##' @export Boot_1_CDF
##' @export fitRT_Boot_1comp
##' @export fitRT_Boot_2comp
##' @export fitRT_Boot_3comp
##' @export fitRT_Boot_2and3comp
##' 
#####################################################################################
#####################################################################################

################################################################################
## Function to calculate 1-CDF and 95 percent CI
calculate_1_CDF<-function(trackll=trackll,x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),t.interval=0.5,output=FALSE,plot_linear=TRUE){
  #library(mltools)
  
  trackll<-filterTrack(trackll,filter=filter)
  trackllname<-names(trackll)
  n<-length(trackll[[1]])
  ## Calculate track length and 1-CDF
  trajLength<-sapply(trackll[[1]],function(x){(x$Frame[dim(x)[1]]-x$Frame[1]+1)*t.interval})
  t=seq(min(t.interval), max(trajLength), by=t.interval)
  #t.plot<-seq(t.interval,x.max,by=t.interval)
  CDF<-mltools::empirical_cdf(trajLength,ubounds=t)
  one_CDF<-(1-(CDF$CDF))
  ONE_CDF<-setNames(data.frame(t,one_CDF), 
                    c("Time intervals (s)",names(trackll)))
  
  ## Calculate survival (1-CDF) and 95 percent CI using "survival" package
  df1=data.frame("t"=rep(1,length(trajLength)),trajLength)
  f1 <- survival::survfit(survival::Surv(trajLength, t) ~ 1, data = df1)
  df2=data.frame("time"=f1$time,"lower 95% CI"=f1$lower,"upper 95% CI"=f1$upper)
  
  df3=data.frame("time"=t,"lower 95% CI"=NA,"upper 95% CI"=NA)
  for(i in seq_along(t)){
    if (df3[,1][i]%in%df2[,1])
      df3[,2][i]=df2[,2][which(df2[,1]==df3[,1][i])]
    if (df3[,1][i]%in%df2[,1])
      df3[,3][i]=df2[,3][which(df2[,1]==df3[,1][i])]
  }
  
  ONE_CDF<-cbind(ONE_CDF,df3[,c(2,3)])
  for(i in seq_along(t)){
    if (ONE_CDF[,2][i]==1){
      ONE_CDF[,3][i]=1
      ONE_CDF[,4][i]=1
    }
  }
  
  if(plot_linear){
    ## Plot in linear scale
    par(mar=c(5.1, 5.1, 4.1, 4.1),xpd=FALSE)
    par(mfrow=c(1,1),bg="white",fg="black")
    
    nice=c(1:10)
    x.max.linear=10^floor(log10(max(t))) * nice[which(max(t) <= 10^floor(log10(max(t))) * nice)[1]]
    plot(t,one_CDF,main=trackllname,xlab="Time (s)",ylab=" ",
         cex.main=1.5,xlim=c(0,x.max.linear),ylim=c(0.0001,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
         bty="n",xaxs="i",yaxs="i",xaxt="n",yaxt="n")
    title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
    axis(1,at=seq(0,x.max.linear,by=5),cex.axis=1.5)
    axis(2,at=seq(0,1,by=0.1),cex.axis=1.5)
    
    lines(ONE_CDF[,1][!is.na(ONE_CDF[,3])],ONE_CDF[,3][!is.na(ONE_CDF[,3])],lty=3,col="blue")
    lines(ONE_CDF[,1][!is.na(ONE_CDF[,4])],ONE_CDF[,4][!is.na(ONE_CDF[,4])],lty=3,col="blue")
    
    ## Add legend and reset plot area.
    par(mar=c(0, 0, 0, 0),xpd=TRUE)
    temp <- legend("topright", legend = rep(" ", 3),
                   text.width = max(strwidth("n = 10000")),
                   pch = c(NA,20,NA),lty=c(NA,NA,3),col=c("black","black","blue"),
                   xjust = 1, yjust = 1, y.intersp = 2,bty="n")
    text(temp$text$x, temp$text$y,
         c(paste("n =",n),"Raw data","95% CI"), 
         col=c("black","black","blue"),pos = 4,cex=1.5)
  }
  
  ## Plot in log-log scale    
  par(mar=c(5.1, 5.1, 4.1, 4.1),xpd=FALSE)
  
  plot(t,one_CDF,main=trackllname,xlab="Time (s)",ylab=" ",
       cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
       bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
  title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
  at.y <- outer(1:9, 10^(log10(y.min):0))
  lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
  lab.y[1,] <- formatC(lab.y[1,],digits=0)
  axis(2, at=at.y, labels=lab.y, las=1)
  at.x <- outer(1:9, 10^(-1:log10(x.max)))
  lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
  axis(1, at=at.x, labels=lab.x, las=1)
  
  polygon(c(ONE_CDF[,1][!is.na(ONE_CDF[,3])],rev(ONE_CDF[,1][!is.na(ONE_CDF[,3])])),
          c(ONE_CDF[,4][!is.na(ONE_CDF[,4])],rev(ONE_CDF[,3][!is.na(ONE_CDF[,3])])),
          border="grey",col="grey")
  points(t,one_CDF,pch=20,cex=0.5)
  
  lines(ONE_CDF[,1][!is.na(ONE_CDF[,3])],ONE_CDF[,3][!is.na(ONE_CDF[,3])],lty=3,col="blue")
  lines(ONE_CDF[,1][!is.na(ONE_CDF[,4])],ONE_CDF[,4][!is.na(ONE_CDF[,4])],lty=3,col="blue")
  
  ## Add legend and reset plot area.
  par(mar=c(0, 0, 0, 0),xpd=TRUE)
  temp <- legend("topright", legend = rep(" ", 3),
                 text.width = max(strwidth("n = 10000")),
                 pch = c(NA,20,NA),lty=c(NA,NA,3),col=c("black","black","blue"),
                 xjust = 1, yjust = 1, y.intersp = 2,bty="n")
  text(10^temp$text$x, 10^temp$text$y,
       c(paste("n =",n),"Raw data","95% CI"), 
       col=c("black","black","blue"),pos = 4,cex=1.5)
  
  ## Output time intervals and corrsponding 1-CDF in .csv format.
  if (output){
    filename<-paste("1-CDF-DwellTime","-",trackllname,"-",format(Sys.time(),"%Y%m%d.%H%M%S"),".csv",sep="")
    write.table(ONE_CDF, filename  , append= F, sep=',', row.names = F)
    cat("\n\n1-CDF of selected tracklls were output in the working directory. 
    If using the same filter range, the curve is exactly the same as the raw data curve in compare.RT.CDF().
    Therefore, this output can be used for plotting and fitting in other programs such as Prism")
  }
  
  ## Return value: data.frame containing time intervals and corrsponding 1-CDF
  return(invisible(ONE_CDF))
}

calculate_1_CDF_multiple<-function(trackll=c(trackll1,trackll2),x.max=100,y.min=0.0001,filter=c(min=3,max=Inf),t.interval=0.5,
                                   x.max.linear=NULL,output=FALSE,plot_linear=FALSE,plotCI=TRUE, plotType="l"){
  #library(mltools)
  
  #one_CDF=c()
  ONE_CDF=c()
  n=c()
  
  for (i in seq_along(trackll)){
    trackll.i<-filterTrack(trackll[i],filter=filter)
    n.i<-length(trackll.i[[1]])
    ## Calculate track length and 1-CDF
    trajLength<-sapply(trackll.i[[1]],function(x){(x$Frame[dim(x)[1]]-x$Frame[1]+1)*t.interval})
    t=seq(min(t.interval), max(trajLength), by=t.interval)
    #t.plot<-seq(t.interval,x.max,by=t.interval)
    CDF<-mltools::empirical_cdf(trajLength,ubounds=t)
    one_CDF.i<-(1-(CDF$CDF))
    ONE_CDF.i<-setNames(data.frame(t,one_CDF.i), 
                      c("Time intervals (s)",names(trackll.i)))
    
    ## Calculate survival (1-CDF) and 95 percent CI using "survival" package
    df1=data.frame("t"=rep(1,length(trajLength)),trajLength)
    f1 <- survival::survfit(survival::Surv(trajLength, t) ~ 1, data = df1)
    df2=data.frame("time"=f1$time,"lower 95% CI"=f1$lower,"upper 95% CI"=f1$upper)
    
    df3=data.frame("time"=t,"lower 95% CI"=NA,"upper 95% CI"=NA)
    for(i in seq_along(t)){
      if (df3[,1][i]%in%df2[,1])
        df3[,2][i]=df2[,2][which(df2[,1]==df3[,1][i])]
      if (df3[,1][i]%in%df2[,1])
        df3[,3][i]=df2[,3][which(df2[,1]==df3[,1][i])]
    }
    
    ONE_CDF.i<-cbind(ONE_CDF.i,df3[,c(2,3)])
    for(i in seq_along(t)){
      if (ONE_CDF.i[,2][i]==1){
        ONE_CDF.i[,3][i]=1
        ONE_CDF.i[,4][i]=1
      }
    }
    
    #one_CDF=append(one_CDF,one_CDF.i)
    ONE_CDF=c(ONE_CDF,list(ONE_CDF.i))
    n=append(n,n.i)
    
  }
  
  cl<-c("black","#FF8E8B","#65B9FF","#FF7DE6","#44D03D","#DF96FF","#F6A600","#00D4EF","#00D9B0","#B1C100")
  
  if(plot_linear){
    ## Plot in linear scale
    par(mar=c(5.1, 5.1, 4.1, 4.1),xpd=FALSE)
    par(mfrow=c(1,1),bg="white",fg="black")
    
    nice=c(1:10)
    if(is.null(x.max.linear)){
      x.max.linear=10^floor(log10(max(t))) * nice[which(max(t) <= 10^floor(log10(max(t))) * nice)[1]]
    }
    
    plot(ONE_CDF[[1]][,1],ONE_CDF[[1]][,2],main=" ",xlab="Time (s)",ylab=" ",
         cex.main=1.5,xlim=c(0,x.max.linear),ylim=c(0.0001,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
         bty="n",xaxs="i",yaxs="i",xaxt="n",yaxt="n",type = plotType)
    title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
    axis(1,at=seq(0,x.max.linear,by=5),cex.axis=1.5)
    axis(2,at=seq(0,1,by=0.1),cex.axis=1.5)
    
    for (i in seq_along(trackll)){
      if(plotType=="l"){
          lines(ONE_CDF[[i]][,1],ONE_CDF[[i]][,2],pch=20,col=cl[i],cex=0.5)
      }else{
          points(ONE_CDF[[i]][,1],ONE_CDF[[i]][,2],pch=20,col=cl[i],cex=0.5)
      }
        
      if (plotCI){
        lines(ONE_CDF[[i]][,1][!is.na(ONE_CDF[[i]][,3])],ONE_CDF[[i]][,3][!is.na(ONE_CDF[[i]][,3])],lty=3,col="grey50")
        lines(ONE_CDF[[i]][,1][!is.na(ONE_CDF[[i]][,4])],ONE_CDF[[i]][,4][!is.na(ONE_CDF[[i]][,4])],lty=3,col="grey50")
      }
      
    }
    
    ## Add legend and reset plot area.
    par(mar=c(0, 0, 0, 0),xpd=TRUE)
    temp <- legend("topright", legend = rep(" ", length(trackll)),
                   text.width = max(strwidth(paste(rep(names(trackll))," ( n = ",rep(c(n))," )",sep=""))),
                   xjust = 1, yjust = 1, y.intersp = 0.5,bty="n")
    text(temp$rect$left + temp$rect$w, temp$text$y,
         paste(rep(names(trackll)), 
               rep(" ( n=",length(trackll)),
               rep(n),
               rep(")",length(trackll))), 
         col=cl,pos = 2,cex=1.2)
  }
  
  ## Plot in log-log scale    
  par(mar=c(5.1, 5.1, 4.1, 4.1),xpd=FALSE)
  
  plot(ONE_CDF[[1]][,1],ONE_CDF[[1]][,2],main=" ",xlab="Time (s)",ylab=" ",
       cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
       bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n", type = plotType)
  title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
  at.y <- outer(1:9, 10^(log10(y.min):0))
  lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
  lab.y[1,] <- formatC(lab.y[1,],digits=0)
  axis(2, at=at.y, labels=lab.y, las=1)
  at.x <- outer(1:9, 10^(-1:log10(x.max)))
  lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
  axis(1, at=at.x, labels=lab.x, las=1)
  
  for (i in seq_along(trackll)){
    if(plotCI){
      polygon(c(ONE_CDF[[i]][,1][!is.na(ONE_CDF[[i]][,3])],rev(ONE_CDF[[i]][,1][!is.na(ONE_CDF[[i]][,3])])),
              c(ONE_CDF[[i]][,4][!is.na(ONE_CDF[[i]][,4])],rev(ONE_CDF[[i]][,3][!is.na(ONE_CDF[[i]][,3])])),
              border=grDevices::adjustcolor(cl[i], alpha.f = 0.3),col=grDevices::adjustcolor(cl[i], alpha.f = 0.3))
      
    }
    
      if(plotType=="l"){
          lines(ONE_CDF[[i]][,1],ONE_CDF[[i]][,2],pch=20,col=cl[i],cex=0.5)
      }else{
          points(ONE_CDF[[i]][,1],ONE_CDF[[i]][,2],pch=20,col=cl[i],cex=0.5)
      }
    
    #lines(ONE_CDF[[i]][,1][!is.na(ONE_CDF[[i]][,3])],ONE_CDF[[i]][,3][!is.na(ONE_CDF[[i]][,3])],lty=3,col="blue")
    #lines(ONE_CDF[[i]][,1][!is.na(ONE_CDF[[i]][,4])],ONE_CDF[[i]][,4][!is.na(ONE_CDF[[i]][,4])],lty=3,col="blue")
    
  }
  
  ## Add legend and reset plot area.
  par(mar=c(0, 0, 0, 0),xpd=TRUE)
  temp <- legend("bottomleft", legend = rep(" ", length(trackll)),
                 text.width = max(strwidth(paste(rep(names(trackll))," ( n = ",rep(c(n))," )",sep=""))),
                 xjust = 1, yjust = 1, y.intersp = 0.5,bty="n")
  text(10^temp$rect$left, 10^temp$text$y,
       paste(rep(names(trackll)), 
             rep(" ( n=",length(trackll)),
             rep(n),
             rep(")",length(trackll))), 
       col=cl,pos = 4,cex=1.2)
  
  ## Output time intervals and corrsponding 1-CDF in .csv format.
  if (output){
    for (i in seq_along(trackll)){
      filename<-paste("1-CDF-DwellTime","-",names(trackll)[i],"-",format(Sys.time(),"%Y%m%d.%H%M%S"),".csv",sep="")
      write.table(ONE_CDF[[i]], filename  , append= F, sep=',', row.names = F)
      cat("\n\n1-CDF of selected tracklls were output in the working directory. 
    If using the same filter range, the curve is exactly the same as the raw data curve in compare.RT.CDF().
    Therefore, this output can be used for plotting and fitting in other programs such as Prism")
      
    }
  }
  ## Return value: data.frame containing time intervals and corrsponding 1-CDF
  return(invisible(ONE_CDF))
}

########################################################################################
## Function for 2 or 3-component exponential decay fitting
twoCompFitRT=function(t,P,t.interval,start=list(k_s=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1)),maxiter.search=2e3,k_ns=FALSE){
  
  ## Equation for two component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p2 =function(t,alpha,k_s,k_ns){
    alpha*exp(-k_s*(t)) + (1-alpha)*exp(-k_ns*(t))}
  
  ## First fit using nls2
  k.search.tcfit=nls2::nls2(P ~ p2(t,alpha,k_s,k_ns),start=data.frame(start),
                            # algorithm="brute-force",
                            algorithm="random-search",
                            control = nls.control(maxiter = maxiter.search))
  
  ## Local optimization using nlsLM.
  
  if(k_ns == FALSE){
    tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns),
                            start=coef(k.search.tcfit),
                            lower=c(0,0,0),
                            upper=c(Inf,Inf,1)) 
  }else if (length(k_ns)==2){
    tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns),
                            start=coef(k.search.tcfit),
                            lower=c(0,k_ns[1],0),
                            upper=c(Inf,k_ns[2],1))
  }
  ## Use a fixex k_ns value given by user.
  else{
    tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns),
                            start=coef(k.search.tcfit),
                            lower=c(0,k_ns,0),
                            upper=c(Inf,k_ns,1))
  }
  
  return(tcfit)
}


twoCompFitRT_weighted=function(t,P,t.interval,start=list(k_s=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1)),
                      weighting=TRUE,maxiter.search=2e3){
  
  ## Equation for two component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p2 =function(t,alpha,k_s,k_ns){
        alpha*exp(-k_s*(t)) + (1-alpha)*exp(-k_ns*(t))}
    
    ## First fit using nls2
    k.search.tcfit=nls2::nls2(P ~ p2(t,alpha,k_s,k_ns),start=data.frame(start),
                              # algorithm="brute-force",
                              algorithm="random-search",
                              control = nls.control(maxiter = maxiter.search))
    
    ## Local optimization using nlsLM.
    
    if (weighting){
      #data=as.data.frame(cbind(P,t))
      data=data.frame(P,t)
      #weight=1/(P+0.000001)
      #weight=1/(P+0.00000001)^2
      #weight=1/abs(log10(P+0.00000001))
      weight=1/P
      weight[which(weight==Inf)]<-max(weight[which(weight!=Inf)])
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns),data = data,
                              start=coef(k.search.tcfit),
                              lower=c(0,0,0),
                              upper=c(Inf,Inf,1),weights = weight)
    }else{
      tcfit=minpack.lm::nlsLM(P ~ p2(t,alpha,k_s,k_ns),
                              start=coef(k.search.tcfit),
                              lower=c(0,0,0),
                              upper=c(Inf,Inf,1)) 
    }
        
      

   return(tcfit)
}

## Three component fitting
threeCompFitRT=function(t,P,t.interval,start=list(k_s=c(1/600,1/t.interval),k_m=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),beta=c(1e-3,1)),maxiter.search=2e3,k_ns=FALSE){
  
  ## Equation for three component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p3 =function(t,alpha,beta,k_s,k_m,k_ns){
    alpha*exp(-k_s*(t)) + beta*exp(-k_m*(t)) + (1-alpha-beta)*exp(-k_ns*(t))}
  
  ## First fit using nls2
  k.search.thcfit=nls2::nls2(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),start=data.frame(start),
                             # algorithm="brute-force",
                             algorithm="random-search",
                             control = nls.control(maxiter = maxiter.search))
  
  ## Local optimization using nlsLM.
  
  if(k_ns == FALSE){
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),
                             start=coef(k.search.thcfit),
                             lower=c(0,0,0,0,0),
                             upper=c(Inf,Inf,Inf,1,1))
  }else if (length(k_ns)==2){
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),
                             start=coef(k.search.thcfit),
                             lower=c(0,0,k_ns[1],0,0),
                             upper=c(k_ns[2],k_ns[2],k_ns[2],1,1))
  }
  ## Use a fixex k_ns value given by user.
  else{
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),
                             start=coef(k.search.thcfit),
                             lower=c(0,0,k_ns,0,0),
                             upper=c(k_ns,k_ns,k_ns,1,1))
  }
  
  return(thcfit)
}


threeCompFitRT_weighted=function(t,P,t.interval,start=list(k_s=c(1/600,1/t.interval),k_m=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),beta=c(1e-3,1)),
                        weighting=TRUE,maxiter.search=2e3,k_ns=FALSE){
  
  ## Equation for three component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p3 =function(t,alpha,beta,k_s,k_m,k_ns){
    alpha*exp(-k_s*(t)) + beta*exp(-k_m*(t)) + (1-alpha-beta)*exp(-k_ns*(t))}
  
  ## First fit using nls2
  k.search.thcfit=nls2::nls2(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),start=data.frame(start),
                            # algorithm="brute-force",
                            algorithm="random-search",
                            control = nls.control(maxiter = maxiter.search))
  
  ## Local optimization using nlsLM.
  if(weighting){
    data=as.data.frame(cbind(P,t))
    #weight=1/(P+0.000001)
    #weight=1/(P+0.00000001)^2
    #weight=1/abs(log10(P+0.00000001))
    weight=1/P
    weight[which(weight==Inf)]<-max(weight[which(weight!=Inf)])
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),data=data,
                             start=coef(k.search.thcfit),
                             lower=c(0,0,0,0,0),
                             upper=c(Inf,Inf,Inf,1,1),weights = weight)
  }else{
    thcfit=minpack.lm::nlsLM(P ~ p3(t,alpha,beta,k_s,k_m,k_ns),
                             start=coef(k.search.thcfit),
                             lower=c(0,0,0,0,0),
                             upper=c(Inf,Inf,Inf,1,1))
  }
  
  return(thcfit)
}


oneCompFitRT=function(t,P,t.interval,start=list(k=c(1/600,1/t.interval)),maxiter.search=2e3){
  
  ## Equation for two component 1-CDF fitting. shift the values of time points corresponding to each P value, 
  ##so that the first time point is 0. This would make the fitting more accurate.
  p1 =function(t,alpha,k_s,k_ns){
    exp(-k*(t)) }
  
  ## First fit using nls2
  
  # Determine an initial value
  
  k=truncnorm::rtruncnorm(1,a=data.frame(start)[1,],b=data.frame(start)[2,])
  
  start=list(k=k)
  k.search.ocfit=nls2::nls2(P ~ p1(t,k),start=data.frame(start),
                            # algorithm="brute-force",
                            algorithm="random-search",
                            control = nls.control(maxiter = maxiter.search))
  
  ## Local optimization using nlsLM.
  
  
    ocfit=minpack.lm::nlsLM(P ~ p1(t,k),
                            start=coef(k.search.ocfit),
                            lower=c(0),
                            upper=c(Inf)) 
    
  return(ocfit)
}


################################################################################
# Helper/evaluation functions. Use whichever are necessary.
concat.text=function(x,y,txt,col) { 
  thisx<-x 
  for(txtstr in seq_along(txt)) { 
    text(thisx,y,txt[txtstr],col=col[txtstr],adj=0) 
    thisx<-10^(log10(thisx)+strwidth(txt[txtstr]))
  } 
} 

oneComponentPrediction = function(t, k){
  return(exp(-k*t))
}

twoComponentPrediction = function(t, alpha, k_s, k_ns){
  return(alpha*exp(-k_s*t)+(1-alpha)*exp(-k_ns*t))
}

threeComponentPrediction = function(t, alpha, beta, k_s, k_m, k_ns){
  return(alpha*exp(-k_s*t)+beta*exp(-k_m*t)+(1-alpha-beta)*exp(-k_ns*t))
}

powerLawPrediction = function(t, A, k){
  return(A*(t^(-k)))
}

plotPrediction = function(t, P, P_pred){
  df = data.frame(t, P, P_pred)
  p <- ggplot(df, aes(t)) + 
    geom_line(aes(y=P, color="Data")) +
    geom_line(aes(y=P_pred, color="Fit")) + 
    scale_x_log10(limits = c(0.1,100)) +
    scale_y_log10(limits = c(0.0001, 1))
  p
}

residualPlot = function(t, P, P_pred){
  residuals = P-P_pred
  #plot(t, residuals, ylab= "Residuals", xlab ="t", type="l")
  plot(t, residuals, ylab= "Residuals", xlab =" ", type="p",cex=0.8,
       las=1,bty="n",axes = FALSE)
  axis(1, at=seq(floor(min(t)), ceiling(max(t)), 5))
  axis(2, at=seq(floor(min(residuals)), ceiling(max(residuals)), 0.005),las=1)
  title(xlab="Time (s)",cex.lab=1,line=-1)
  abline(h = 0)
}

RSS = function(P, P_pred){
  return(sum((P-P_pred)^2))
}

# params = 3, for two comp
# params = 5, for three comp
AIC = function(P, P_pred, params){
  n = length(P)
  k = params
  df = n-k
  return(2*df+n*log(RSS(P, P_pred)))
}

# params = 3, for two comp
# params = 5, for three comp
BIC = function(P, P_pred, params){
  n = length(P)
  k = params
  df = n-k
  return(log(n)*df+n*log(RSS(P, P_pred)))
}

################################################################################
## Generate bootstrapped data of 1-CDF:


Boot_1_CDF<-function(trackll=trackll,t.interval=0.25,R=100,output=FALSE,plot=TRUE,x.max=100,y.min=0.0001){
  
  trajLength<-sapply(trackll[[1]],function(x){(x$Frame[dim(x)[1]]-x$Frame[1]+1)*t.interval})
  t<-seq(t.interval,max(trajLength),by=t.interval)
  t.plot<-seq(t.interval,x.max,by=t.interval)
  CDF<-mltools::empirical_cdf(trajLength,ubounds=seq(t.interval, max(trajLength), by=t.interval))
  P<-(1-(CDF$CDF))
  
  name=names(trackll)
  
  resamples <- lapply(1:R, function(i) sample(trajLength, replace = T))
  CDF.resamples<-lapply(resamples,function(x)
  {mltools::empirical_cdf(x,ubounds=seq(t.interval, max(x), by=t.interval))})
  P.resamples<-lapply(CDF.resamples,function(x)(1-(x$CDF)))
  
  
  if(plot){
    par(mar = c(5,6,4,2) + 0.1)
    plot(t.plot,P[1:length(t.plot)],main="Bootstrapped data",xlab="Time (s)",ylab=" ",
         cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
         bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
    title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
    at.y <- outer(1:9, 10^(log10(y.min):0))
    lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
    lab.y[1,] <- formatC(lab.y[1,],digits=0)
    axis(2, at=at.y, labels=lab.y, las=1)
    at.x <- outer(1:9, 10^(-1:log10(x.max)))
    lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
    axis(1, at=at.x, labels=lab.x, las=1)
    
    ##color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
    color=rainbow(2*R)
    col=sample(color, R)
    
    for (i in 1:R){
      lines(t.plot,P.resamples[[i]][1:length(t.plot)],col=col[i],lwd=1.5)
    }
    
    
    points(t.plot,P[1:length(t.plot)],pch=20,cex=1)
    
    legend("bottomleft",legend = c(names(trackll),paste("n = ",length(trackll[[1]]),sep=""),
                                   "Original data"," "),
           pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black","black","red"),
           col=c("black","black","black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
    temp <- legend("bottomleft", legend = c(" ", " "," "," "),
                   pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,
                   col=c("black","black","black","red"),
                   text.width = 10^(strwidth("Bootstrap iterations: 100")),
                   y.intersp = 0.8,x.intersp = 0.5,bty="n",cex=1)
    
    ctext<-c('B','o','o','t','s','t','r','a','p ','i','t','e','r','a','t','i','o','n','s',': ',R)
    par(font=2)
    #concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=sample(col,length(ctext))) 
    concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=rainbow(length(ctext))) 
  }
  
  ## Output original 1-CDF along with resampled 1-CDF
  P.output=append(list(P),P.resamples)
  t.output=seq(t.interval,max(sapply(P.output,function(x)(length(x)))),by=t.interval)
  tP.output=append(list(t.output),P.output)
  tP.output=plyr::ldply(tP.output, rbind)
  tP.output[is.na(tP.output)] <- 0
  tP.output=as.data.frame(t(tP.output))
  colnames(tP.output)<-c("Time (s)","Oritinal",paste("Resampled_",seq(1:R)))
  if(output){
    filename<-paste("1-CDF-Bootstrap-",names(trackll),"-",format(Sys.time(),"%Y%m%d_%H%M%S"),".csv",sep="")
    write.table(tP.output, filename  , append= F, sep=',', row.names = F)
  }
  name=names(trackll)
  return(invisible(list("Time"=t.output,"1-CDF"=P.output,"Name"=name,"n"=length(trackll[[1]]))))
}


################################################################################
## 2 or 3-component exponential decay fitting of original and bootstrapped data
fitRT_Boot_1comp<-function(BootData,t.interval=0.25,x.max=100,y.min=0.0001,output=FALSE,plot.fit=TRUE){
  ## Output plots into a PDF file
  pdf(paste("Bootstrapped data 1-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".pdf",sep=""),width=11,height=8.5)
  R=length(BootData$`1-CDF`)
  P=BootData$`1-CDF`
  ## Plot original 1-CDF curve as dots in log scale x, y axis
  t.plot<-seq(t.interval,x.max,by=t.interval)
  par(mar = c(5,6,4,2) + 0.1)
  plot(t.plot,P[[1]][1:length(t.plot)],main="Bootstrapped data",xlab="Time (s)",ylab=" ",
       cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
       bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
  title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
  at.y <- outer(1:9, 10^(log10(y.min):0))
  lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
  lab.y[1,] <- formatC(lab.y[1,],digits=0)
  axis(2, at=at.y, labels=lab.y, las=1)
  at.x <- outer(1:9, 10^(-1:log10(x.max)))
  lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
  axis(1, at=at.x, labels=lab.x, las=1)
  
  ## Plot bootstrapped 1-CDF curves as lines in random color
  ##color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
  
  color=rainbow(2*R)
  col=sample(color, R)
  
  for (i in 2:R){
    lines(t.plot,P[[i]][1:length(t.plot)],col=col[i],lwd=1.5)
  }
  
  ## Add original 1-CDF curve as dots on top
  points(t.plot,P[[1]][1:length(t.plot)],pch=20,cex=1)
  
  ## Legend
  legend("bottomleft",legend = c(BootData$Name,paste("n = ",BootData$n,sep=""),
                                 "Original data"," "),
         pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black","black","red"),
         col=c("black","black","black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
  temp <- legend("bottomleft", legend = c(" ", " "," "," "),
                 pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,
                 col=c("black","black","black","red"),
                 text.width = 10^(strwidth("Bootstrap iterations: 100")),
                 y.intersp = 0.8,x.intersp = 0.5,bty="n",cex=1)
  
  ctext<-c('B','o','o','t','s','t','r','a','p ','i','t','e','r','a','t','i','o','n','s',': ',R-1)
  par(font=2)
  
  concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=rainbow(length(ctext)))
  
  
  cat("\nStart fitting bootstrapped samples...\n")
  
  ## fit bootstrapped data
  ## 1-component fitting
  boot.1.fitRT=c()
  
  par(mfrow=c(2,2),bg="white",fg="black")
  for (i in 1:R){
    if (i==1){
      cat("\nOriginal data --- 1-component fitting")
    }else{
      cat(paste("\n","Bootstrapped data # ",i-1," --- 1-component fitting",sep=""))
    }
    
    ## Generate X values of data points for fitting
    if(length(which(P[[i]] == 1))>=2){
      t.fit<-seq(t.interval*length(which(P[[i]] == 1)),t.interval*length(P[[i]]),by=t.interval)
    }else{
      t.fit<-seq(t.interval,t.interval*length(P[[i]]),by=t.interval)
    }
    
    ## Generate Y values of data points for fitting
    ## Remove multiple "1" of P values, leaving only one "1" value.
    ## The rest P values will be used for fitting.  
    if(length(which(P[[i]] == 1))>=2){
      P.fit<-P[[i]][-(1:(length(which(P[[i]] == 1))-1))]
    } else{
      P.fit<-P[[i]]
    }
    
    
    # t minimum correction
    t.fit.shift = t.fit - min(t.fit)
    
    result = NULL
    attempt = 1
    maximum_attempts = 1000
    while( (is.null(result) && attempt <= maximum_attempts)){
      attempt = attempt + 1
      try(
        result<-oneCompFitRT(t=t.fit.shift,P=P.fit,t.interval,start=list(k=c(1/600,1/t.interval)),
                             maxiter.search=1e3),
        silent = TRUE
      )
      #cat("\n")
      #print(coef(result))
      #cat(paste0("\nalpha+beta=",as.numeric((coef(result)['alpha'] + coef(result)['beta']))))
      #cat(paste0("\nattemp=",attempt))
    }
    
    if(is.null(result)){
      dev.off()
      cat("\n\n!!! Your data does not fit 1-component exponential decay !!!\n\n")
      stop("Data does not fit")
    }
    result=coef(result)
    
    # Calculate predicted/expected P from the fit
    P_pred = oneComponentPrediction(t.fit.shift, result['k'])
    
    ## Calculate the fitting errors
    rss=RSS(P.fit, P_pred)
    aic=AIC(P.fit, P_pred, 3)
    bic=BIC(P.fit, P_pred, 3)
    #result=c(result[2:4],rss,aic,bic)
    result=c(result,rss,aic,bic)
    names(result)[2:4]=c("RSS","AIC","BIC")
    
    boot.1.fitRT=rbind(boot.1.fitRT,result)
    
    if (plot.fit||i<=3){
      ## Plot the data to be fitted in log-log scale
      par(mar = c(5,6,4,2) + 0.1)
      if (i==1){
        plot(t.plot,P[[i]][1:length(t.plot)],main="Original data",xlab="Time (s)",ylab=" ",
             cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
             bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
      }
      else{
        plot(t.plot,P[[i]][1:length(t.plot)],main=paste0("Bootstrapped data # ",i-1),xlab="Time (s)",ylab=" ",
             cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
             bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
      }
      
      title(ylab="Survival probability (1-CDF)",cex.lab=1.1,line=3.6)
      axis(2, at=at.y, labels=lab.y, las=1)
      axis(1, at=at.x, labels=lab.x, las=1)
      # Plot fitted curve
      p1_model = function(x){
        exp(-result['k']*(x-min(t.fit)))
      }
      curve(p1_model,add=T,col="red",lwd=2)
      
      ## Print parameters on the plot
      result.text=c(expression(italic(P(t) == e^-k*''^t)),
                    as.expression(bquote(italic('k'==.(result['k'])))),
                    "  ",
                    as.expression(bquote(italic('RSS'==.(result['RSS'])))),
                    as.expression(bquote(italic('AIC'==.(result['AIC'])))),
                    as.expression(bquote(italic('BIC'==.(result['BIC'])))),
                    " "
      )
      legend("left",legend=result.text,pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
      par(font=1)
      legend("topright",legend = c("Data      ","Fit      "),
             pch=c(20,NA),lty=c(NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black"),
             col=c("black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
    }
    
  }
  
  rownames(boot.1.fitRT)<-c(0:(R-1))
  
  boot.1.fitRT.df=as.data.frame(boot.1.fitRT)
  boot.1.fitRT.filter=boot.1.fitRT.df[which(boot.1.fitRT.df[,1]>0),]
  
  ## Plot RSS
  options(scipen=10)
  plot(rownames(boot.1.fitRT.filter),boot.1.fitRT.filter$RSS,type='p',main="RSS of 1-component fitting",
       xlab = "Data #", ylab = "RSS",las=1, cex.axis=0.8,xaxt="n")
  axis(1, at = seq(0, (R-1), by = 5), las=1)
  
  hist<-hist(as.numeric(boot.1.fitRT.filter[,1]),main = "Histogram of 1 component fitting", 
             xlab = as.expression(bquote(italic('k'))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  title(main=BootData$Name,line=0.2)
  legend_text=c(as.expression(bquote('Mean of k' ==.(mean(as.numeric(boot.1.fitRT.filter[,1]))))),
                as.expression(bquote('SD of k'['slow'] ==.(sd(as.numeric(boot.1.fitRT.filter[,1]))))),
                as.expression(bquote('n'==.(length(boot.1.fitRT.filter[,1])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  
  dev.off()
  
  if(output){
    boot.1.fitRT.filter.2 <- apply(boot.1.fitRT.filter,2,as.numeric)
    filename<-paste("Bootstrapped data 1-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".csv",sep="")
    write.table(boot.1.fitRT.filter.2, filename, append= F, sep=",",  col.names=NA,row.names = row.names(boot.1.fitRT.filter))
  }
  
  cat("\n\nPDF output in working directory")
  return(boot.1.fitRT.filter)
  
}


fitRT_Boot_2comp<-function(BootData,t.interval=0.25,x.max=100,y.min=0.0001,output=FALSE,k_ns=FALSE){
  ## Output plots into a PDF file
  pdf(paste("Bootstrapped data 2-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".pdf",sep=""),width=11,height=8.5)
  R=length(BootData$`1-CDF`)
  P=BootData$`1-CDF`
  ## Plot original 1-CDF curve as dots in log scale x, y axis
  t.plot<-seq(t.interval,x.max,by=t.interval)
  par(mar = c(5,6,4,2) + 0.1)
  plot(t.plot,P[[1]][1:length(t.plot)],main="Bootstrapped data",xlab="Time (s)",ylab=" ",
       cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
       bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
  title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
  at.y <- outer(1:9, 10^(log10(y.min):0))
  lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
  lab.y[1,] <- formatC(lab.y[1,],digits=0)
  axis(2, at=at.y, labels=lab.y, las=1)
  at.x <- outer(1:9, 10^(-1:log10(x.max)))
  lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
  axis(1, at=at.x, labels=lab.x, las=1)
  
  ## Plot bootstrapped 1-CDF curves as lines in random color
  ##color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
  
  color=rainbow(2*R)
  col=sample(color, R)
  
  for (i in 2:R){
    lines(t.plot,P[[i]][1:length(t.plot)],col=col[i],lwd=1.5)
  }
  
  ## Add original 1-CDF curve as dots on top
  points(t.plot,P[[1]][1:length(t.plot)],pch=20,cex=1)
  
  ## Legend
  legend("bottomleft",legend = c(BootData$Name,paste("n = ",BootData$n,sep=""),
                                 "Original data"," "),
         pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black","black","red"),
         col=c("black","black","black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
  temp <- legend("bottomleft", legend = c(" ", " "," "," "),
                 pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,
                 col=c("black","black","black","red"),
                 text.width = 10^(strwidth("Bootstrap iterations: 100")),
                 y.intersp = 0.8,x.intersp = 0.5,bty="n",cex=1)
  
  ctext<-c('B','o','o','t','s','t','r','a','p ','i','t','e','r','a','t','i','o','n','s',': ',R-1)
  par(font=2)
  
  concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=rainbow(length(ctext)))
  
  
  cat("\nStart fitting bootstrapped samples...\n")
  
  ## fit bootstrapped data
  ## 2-component fitting
  boot.2.fitRT=c()
  
  par(mfrow=c(2,2),bg="white",fg="black")
  for (i in 1:R){
    if (i==1){
      cat("\nOriginal data --- 2-component fitting")
    }else{
      cat(paste("\n","Bootstrapped data # ",i-1," --- 2-component fitting",sep=""))
    }
    
    ## Plot the data to be fitted in log-log scale
    par(mar = c(5,6,4,2) + 0.1)
    if (i==1){
      plot(t.plot,P[[i]][1:length(t.plot)],main="Original data",xlab="Time (s)",ylab=" ",
           cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
           bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
    }
    else{
      plot(t.plot,P[[i]][1:length(t.plot)],main=paste0("Bootstrapped data # ",i-1),xlab="Time (s)",ylab=" ",
           cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
           bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
    }
    
    title(ylab="Survival probability (1-CDF)",cex.lab=1.1,line=3.6)
    axis(2, at=at.y, labels=lab.y, las=1)
    axis(1, at=at.x, labels=lab.x, las=1)
    
    ## Generate X values of data points for fitting
    if(length(which(P[[i]] == 1))>=2){
      t.fit<-seq(t.interval*length(which(P[[i]] == 1)),t.interval*length(P[[i]]),by=t.interval)
    }else{
      t.fit<-seq(t.interval,t.interval*length(P[[i]]),by=t.interval)
    }
    
    ## Generate Y values of data points for fitting
    ## Remove multiple "1" of P values, leaving only one "1" value.
    ## The rest P values will be used for fitting.  
    if(length(which(P[[i]] == 1))>=2){
      P.fit<-P[[i]][-(1:(length(which(P[[i]] == 1))-1))]
    } else{
      P.fit<-P[[i]]
    }
    
    
    # t minimum correction
    t.fit.shift = t.fit - min(t.fit)
    
    result<-twoCompFitRT(t=t.fit.shift,P=P.fit,t.interval,start=list(k_s=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1)),
                                 maxiter.search=1e3,
                                 k_ns=k_ns)
    
    result=coef(result)[c(3,1,2)]
    if (as.numeric(result['k_s'])>as.numeric(result['k_ns'])){
      result=result[c(1,3,2)]
      result[1]=1-as.numeric(result[1])
      names(result)=c("alpha","k_s","k_ns")
    }
    
    # Calculate predicted/expected P from the fit
    P_pred = twoComponentPrediction(t.fit.shift, result['alpha'], result['k_s'], result['k_ns'])
    
    ## Calculate the fitting errors
    rss=RSS(P.fit, P_pred)
    aic=AIC(P.fit, P_pred, 3)
    bic=BIC(P.fit, P_pred, 3)
    #result=c(result[2:4],rss,aic,bic)
    result=c(result,rss,aic,bic)
    names(result)[4:6]=c("RSS","AIC","BIC")
    
    boot.2.fitRT=rbind(boot.2.fitRT,result)
    
    # Plot fitted curve
    p2_model = function(x){
      result['alpha']*exp(-result['k_s']*(x-min(t.fit))) + (1- result['alpha'])*exp(-result['k_ns']*(x-min(t.fit)))
    }
    curve(p2_model,add=T,col="red",lwd=2)
    
    ## Print parameters on the plot
    result.text=c(expression(italic(P(t) == alpha*e^-k[s]*''^t+(1-alpha)*e^-k[ns]*''^t)),
                  as.expression(bquote(italic('k'['s']==.(result['k_s'])))),
                  as.expression(bquote(italic('k'['ns']==.(result['k_ns'])))),
                  as.expression(bquote(italic(alpha==.(result['alpha'])))),
                  "  ",
                  as.expression(bquote(italic('RSS'==.(result['RSS'])))),
                  as.expression(bquote(italic('AIC'==.(result['AIC'])))),
                  as.expression(bquote(italic('BIC'==.(result['BIC'])))),
                  " "
    )
    legend("left",legend=result.text,pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
    par(font=1)
    legend("topright",legend = c("Data      ","Fit      "),
           pch=c(20,NA),lty=c(NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black"),
           col=c("black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
  }
  
  rownames(boot.2.fitRT)<-c(0:(R-1))
  
  boot.2.fitRT.df=as.data.frame(boot.2.fitRT)
  boot.2.fitRT.filter=boot.2.fitRT.df[which(boot.2.fitRT.df[,2]>0),]
  
  ## Plot RSS
  options(scipen=10)
  plot(rownames(boot.2.fitRT.filter),boot.2.fitRT.filter$RSS,type='p',main="RSS of 2-component fitting",
       xlab = "Data #", ylab = "RSS",las=1, cex.axis=0.8,xaxt="n")
  axis(1, at = seq(0, (R-1), by = 5), las=1)
  
  hist<-hist(as.numeric(boot.2.fitRT.filter[,2]),main = "Histogram of 2 component fitting", 
       xlab = as.expression(bquote(italic('k'['slow']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  legend_text=c(as.expression(bquote('Mean of k'['slow'] ==.(mean(as.numeric(boot.2.fitRT.filter[,2]))))),
                as.expression(bquote('SD of k'['slow'] ==.(sd(as.numeric(boot.2.fitRT.filter[,2]))))),
                as.expression(bquote('n'==.(length(boot.2.fitRT.filter[,2])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  
  hist<-hist(as.numeric(boot.2.fitRT.filter[,1]),main = "Histogram of 2 component fitting", 
       xlab = as.expression(bquote(italic('F'['slow']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  legend_text=c(as.expression(bquote('Mean of F'['slow'] ==.(mean(as.numeric(boot.2.fitRT.filter[,1]))))),
                as.expression(bquote('SD of F'['slow'] ==.(sd(as.numeric(boot.2.fitRT.filter[,1]))))),
                as.expression(bquote('n'==.(length(boot.2.fitRT.filter[,1])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  
  dev.off()
  
  if(output){
    boot.2.fitRT.filter.2 <- apply(boot.2.fitRT.filter,2,as.numeric)
    filename<-paste("Bootstrapped data 2-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".csv",sep="")
    write.table(boot.2.fitRT.filter.2, filename, append= F, sep=",",  col.names=NA,row.names = row.names(boot.2.fitRT.filter))
  }
  
  cat("\n\nPDF output in working directory")
  return(boot.2.fitRT.filter)

}


fitRT_Boot_3comp<-function(BootData,t.interval=0.25,x.max=100,y.min=0.0001,output=FALSE,k_ns=FALSE){
  ## Output plots into a PDF file
  pdf(paste("Bootstrapped data 3-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".pdf",sep=""),width=11,height=8.5)
  R=length(BootData$`1-CDF`)
  P=BootData$`1-CDF`
  ## Plot original 1-CDF curve as dots in log scale x, y axis
  t.plot<-seq(t.interval,x.max,by=t.interval)
  par(mar = c(5,6,4,2) + 0.1)
  plot(t.plot,P[[1]][1:length(t.plot)],main="Bootstrapped data",xlab="Time (s)",ylab=" ",
       cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
       bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
  title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
  at.y <- outer(1:9, 10^(log10(y.min):0))
  lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
  lab.y[1,] <- formatC(lab.y[1,],digits=0)
  axis(2, at=at.y, labels=lab.y, las=1)
  at.x <- outer(1:9, 10^(-1:log10(x.max)))
  lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
  axis(1, at=at.x, labels=lab.x, las=1)
  
  ## Plot bootstrapped 1-CDF curves as lines in random color
  ##color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]

  color=rainbow(2*R)
  col=sample(color, R)
  
  for (i in 2:R){
    lines(t.plot,P[[i]][1:length(t.plot)],col=col[i],lwd=1.5)
  }
  
  ## Add original 1-CDF curve as dots on top
  points(t.plot,P[[1]][1:length(t.plot)],pch=20,cex=1)
  
  ## Legend
  legend("bottomleft",legend = c(BootData$Name,paste("n = ",BootData$n,sep=""),
                                 "Original data"," "),
         pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black","black","red"),
         col=c("black","black","black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
  temp <- legend("bottomleft", legend = c(" ", " "," "," "),
                 pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,
                 col=c("black","black","black","red"),
                 text.width = 10^(strwidth("Bootstrap iterations: 100")),
                 y.intersp = 0.8,x.intersp = 0.5,bty="n",cex=1)
  ctext<-c('B','o','o','t','s','t','r','a','p ','i','t','e','r','a','t','i','o','n','s',': ',R-1)
  par(font=2)
  
  concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=rainbow(length(ctext)))
  
  
  cat("\nStart fitting bootstrapped samples...\n")
  
  ## fit bootstrapped data
  ## 3-component fitting
  boot.3.fitRT=c()
  
  par(mfrow=c(2,2),bg="white",fg="black")
  for (i in 1:R){
    if (i==1){
      cat("\nOriginal data --- 3-component fitting")
    }else{
      cat(paste("\n","Bootstrapped data # ",i-1," --- 3-component fitting",sep=""))
    }
    
    ## Plot the data to be fitted in log-log scale
    par(mar = c(5,6,4,2) + 0.1)
    if (i==1){
      plot(t.plot,P[[i]][1:length(t.plot)],main="Original data",xlab="Time (s)",ylab=" ",
           cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
           bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
    }
    else{
      plot(t.plot,P[[i]][1:length(t.plot)],main=paste0("Bootstrapped data # ",i-1),xlab="Time (s)",ylab=" ",
           cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
           bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
    }
    
    title(ylab="Survival probability (1-CDF)",cex.lab=1.1,line=3.6)
    axis(2, at=at.y, labels=lab.y, las=1)
    axis(1, at=at.x, labels=lab.x, las=1)
    
    ## Generate X values of data points for fitting
    if(length(which(P[[i]] == 1))>=2){
      t.fit<-seq(t.interval*length(which(P[[i]] == 1)),t.interval*length(P[[i]]),by=t.interval)
    }else{
      t.fit<-seq(t.interval,t.interval*length(P[[i]]),by=t.interval)
    }
    
    ## Generate Y values of data points for fitting
    ## Remove multiple "1" of P values, leaving only one "1" value.
    ## The rest P values will be used for fitting.  
    if(length(which(P[[i]] == 1))>=2){
      P.fit<-P[[i]][-(1:(length(which(P[[i]] == 1))-1))]
    } else{
      P.fit<-P[[i]]
    }
    
    
    # t minimum correction
    t.fit.shift = t.fit - min(t.fit)
    
    result = NULL
    attempt = 1
    maximum_attempts = 50
    while( (is.null(result) && attempt <= maximum_attempts) || 
           coef(result)['alpha']<0 || coef(result)['beta']<0 || 
           (coef(result)['alpha'] + coef(result)['beta']) >1){
      attempt = attempt + 1
      try(
        result<-threeCompFitRT(t=t.fit.shift,P=P.fit,t.interval,start=list(k_s=c(1/600,1/t.interval),k_m=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),beta=c(1e-3,1)),
                               maxiter.search=1e3,
                               k_ns=k_ns),
        silent = TRUE
      )
      #cat("\n")
      #print(coef(result))
      #cat(paste0("\nalpha+beta=",as.numeric((coef(result)['alpha'] + coef(result)['beta']))))
      #cat(paste0("\nattemp=",attempt))
    } 
    
    result=coef(result)[c(4,5,1,2,3)]
    
    if (as.numeric(result["k_s"])>as.numeric(result["k_m"])){
      result=result[c(2,1,4,3,5)]
      names(result)=c("alpha","beta","k_s","k_m","k_ns")
    }
    
    if (as.numeric(result["k_s"])>as.numeric(result["k_ns"])){
      result=result[c(1,2,5,4,3)]
      result[1]=1-as.numeric(result[1])-as.numeric(result[2])
      names(result)=c("alpha","beta","k_s","k_m","k_ns")
    }
    
    if (as.numeric(result["k_m"])>as.numeric(result["k_ns"])){
      result=result[c(1,2,3,5,4)]
      result[2]=1-as.numeric(result[1])-as.numeric(result[2])
      names(result)=c("alpha","beta","k_s","k_m","k_ns")
    }
    
    # Calculate predicted/expected P from the fit
    P_pred = threeComponentPrediction(t.fit.shift, result['alpha'], result['beta'], result['k_s'], result['k_m'], result['k_ns'])
    
    ## Calculate the fitting errors
    rss=RSS(P.fit, P_pred)
    aic=AIC(P.fit, P_pred, 5)
    bic=BIC(P.fit, P_pred, 5)
    result=c(result,rss,aic,bic)
    names(result)[6:8]=c("RSS","AIC","BIC")
    
    boot.3.fitRT=rbind(boot.3.fitRT,result)
    
    # Plot fitted curve
    p3_model = function(x){
      result['alpha']*exp(-result['k_s']*(x-min(t.fit))) + 
        result['beta']*exp(-result['k_m']*(x-min(t.fit))) + 
        (1- result['alpha']-result['beta'])*exp(-result['k_ns']*(x-min(t.fit)))
    }
    curve(p3_model,add=T,col="red",lwd=2)
    
    ## Print parameters on the plot
    result.text=c(expression(italic(P(t) == alpha*e^-k[s]*''^t+beta*e^-k[m]*''^t+(1-alpha-beta)*e^-k[ns]*''^t)),
                  as.expression(bquote(italic('k'['s']==.(result['k_s'])))),
                  as.expression(bquote(italic('k'['m']==.(result['k_m'])))),
                  as.expression(bquote(italic('k'['ns']==.(result['k_ns'])))),
                  as.expression(bquote(italic(alpha==.(result['alpha'])))),
                  as.expression(bquote(italic(beta==.(result['beta'])))),
                  "  ",
                  as.expression(bquote(italic('RSS'==.(result['RSS'])))),
                  as.expression(bquote(italic('AIC'==.(result['AIC'])))),
                  as.expression(bquote(italic('BIC'==.(result['BIC'])))),
                  " "
    )
    legend("left",legend=result.text,pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
    par(font=1)
    legend("topright",legend = c("Data      ","Fit      "),
           pch=c(20,NA),lty=c(NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black"),
           col=c("black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
  }
  
  rownames(boot.3.fitRT)<-c(0:(R-1))
  
  boot.3.fitRT.df=as.data.frame(boot.3.fitRT)
  boot.3.fitRT.filter=boot.3.fitRT.df[which(boot.3.fitRT.df[,1]>0),]
  boot.3.fitRT.filter=boot.3.fitRT.filter[which(boot.3.fitRT.filter[,2]>0),]
  boot.3.fitRT.filter=boot.3.fitRT.filter[which((boot.3.fitRT.filter[,1]+boot.3.fitRT.filter[,2])<=1),]
  boot.3.fitRT.filter=boot.3.fitRT.filter[which(boot.3.fitRT.filter[,3]>0),]
  
  ## Plot RSS
  options(scipen=10)
  plot(rownames(boot.3.fitRT.filter),boot.3.fitRT.filter$RSS,type='p',main="RSS of 3-component fitting",
       xlab = "Data #", ylab = "RSS",las=1, cex.axis=0.8,xaxt="n")
  axis(1, at = seq(0, (R-1), by = 5), las=1)
  
  hist<-hist(as.numeric(boot.3.fitRT.filter[,3]),main = "Histogram of 3 component fitting", 
       xlab = as.expression(bquote(italic('k'['slow']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  legend_text=c(as.expression(bquote('Mean of k'['slow'] ==.(mean(as.numeric(boot.3.fitRT.filter[,3]))))),
                as.expression(bquote('SD of k'['slow'] ==.(sd(as.numeric(boot.3.fitRT.filter[,3]))))),
                as.expression(bquote('n'==.(length(boot.3.fitRT.filter[,3])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  
  hist<-hist(as.numeric(boot.3.fitRT.filter[,1]),main = "Histogram of 3 component fitting", 
       xlab = as.expression(bquote(italic('F'['slow']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  legend_text=c(as.expression(bquote('Mean of F'['slow'] ==.(mean(as.numeric(boot.3.fitRT.filter[,1]))))),
                as.expression(bquote('SD of F'['slow'] ==.(sd(as.numeric(boot.3.fitRT.filter[,1]))))),
                as.expression(bquote('n'==.(length(boot.3.fitRT.filter[,1])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  
  dev.off()
  
  if(output){
    boot.3.fitRT.filter.2 <- apply(boot.3.fitRT.filter,2,as.numeric)
    filename<-paste("Bootstrapped data 3-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".csv",sep="")
    write.table(boot.3.fitRT.filter.2, filename, append= F, sep=",",  col.names=NA,row.names = row.names(boot.3.fitRT.filter))
  }
  
  cat("\n\nPDF output in working directory")
  return(boot.3.fitRT.filter)
  
}


fitRT_Boot_2and3comp<-function(BootData,t.interval=0.25,x.max=100,y.min=0.0001,
                                               cutoff=FALSE,weighting=FALSE,output=FALSE,k_ns=FALSE,plot.fit=TRUE){
  ## Output plots into a PDF file
  pdf(paste("Bootstrapped data 2&3-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".pdf",sep=""),width=11,height=8.5)
  R=length(BootData$`1-CDF`)
  P=BootData$`1-CDF`
  ## Plot original 1-CDF curve as dots in log scale x, y axis
  t.plot<-seq(t.interval,x.max,by=t.interval)
  par(mar = c(5,6,4,2) + 0.1)
  plot(t.plot,P[[1]][1:length(t.plot)],main="Bootstrapped data",xlab="Time (s)",ylab=" ",
       cex.main=1.5,xlim=c(0.1,x.max),ylim=c(y.min,1.11),cex.axis=1.5,cex.lab=1.5,pch=20,cex=0.5,
       bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
  title(ylab="Survival probability (1-CDF)",cex.lab=1.5,line=3.6)
  at.y <- outer(1:9, 10^(log10(y.min):0))
  lab.y <- ifelse(log10(at.y) %% 1 == 0, at.y, NA)
  lab.y[1,] <- formatC(lab.y[1,],digits=0)
  axis(2, at=at.y, labels=lab.y, las=1)
  at.x <- outer(1:9, 10^(-1:log10(x.max)))
  lab.x <- ifelse(log10(at.x) %% 1 == 0, at.x, NA)
  axis(1, at=at.x, labels=lab.x, las=1)
  
  ## Plot bootstrapped 1-CDF curves as lines in random color
  ##color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
  
  color=rainbow(2*R)
  col=sample(color, R)
  
  for (i in 2:R){
    lines(t.plot,P[[i]][1:length(t.plot)],col=col[i],lwd=1.5)
  }
  
  ## Add original 1-CDF curve as dots on top
  points(t.plot,P[[1]][1:length(t.plot)],pch=20,cex=1)
  
  ## Legend
  legend("bottomleft",legend = c(BootData$Name,paste("n = ",BootData$n,sep=""),
                                 "Original data"," "),
         pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black","black","red"),
         col=c("black","black","black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
  temp <- legend("bottomleft", legend = c(" ", " "," "," "),
                 pch=c(NA,NA,20,NA),lty=c(NA,NA,NA,1),seg.len=0.6,lwd = 1.5,
                 col=c("black","black","black","red"),
                 text.width = 10^(strwidth("Bootstrap iterations: 100")),
                 y.intersp = 0.8,x.intersp = 0.5,bty="n",cex=1)
  ctext<-c('B','o','o','t','s','t','r','a','p ','i','t','e','r','a','t','i','o','n','s',': ',R-1)
  par(font=2)
  
  concat.text(10^(temp$text$x[4]),10^(temp$text$y[4]),txt=ctext,col=rainbow(length(ctext)))
  
  
  cat("\nStart fitting bootstrapped samples...\n")
  
  ## fit bootstrapped data
  
  boot.2.fitRT=c()
  boot.3.fitRT=c()
  
  par(mfrow=c(2,2),bg="white",fg="black")
  for (i in 1:R){
    
    
    if(cutoff==FALSE){
      ## Generate X values of data points for fitting
      
      if(length(which(P[[i]] == 1))>=2){
        t.fit<-seq(t.interval*length(which(P[[i]] == 1)),t.interval*length(P[[i]]),by=t.interval)
      }else{
        t.fit<-seq(t.interval,t.interval*length(P[[i]]),by=t.interval)
      }
      
      ## Generate Y values of data points for fitting
      ## Remove multiple "1" of P values, leaving only one "1" value.
      ## The rest P values will be used for fitting.  
      if(length(which(P[[i]] == 1))>=2){
        P.fit<-P[[i]][-(1:(length(which(P[[i]] == 1))-1))]
      } else{
        P.fit<-P[[i]]
      }
    }else{
      ## Generate X values of data points for fitting
      
      if(length(which(P[[i]] == 1))>=2){
        t.fit<-seq(t.interval*length(which(P[[i]] == 1)),cutoff,by=t.interval)
      }else{
        t.fit<-seq(t.interval,cutoff,by=t.interval)
      }
      
      ## Generate Y values of data points for fitting
      ## Remove multiple "1" of P values, leaving only one "1" value.
      ## The rest P values will be used for fitting.  
      if(length(which(P[[i]] == 1))>=2){
        P.fit<-P[[i]][-(1:(length(which(P[[i]] == 1))-1))]
      } 
      P.fit<-P.fit[seq_along(t.fit)]
    }
    
    
    # t minimum correction
    t.fit.shift = t.fit - min(t.fit)
    
    
    ####### 2-component fitting
    if (i==1){
      cat("\r","Original data","         2-component fitting")
    }else{
      cat("\r","Bootstrapped data # ",i-1,"      2-component fitting")
    }
    
    result = NULL
    attempt = 0
    maximum_attempts = 50
    while( (is.null(result) && attempt <= maximum_attempts) || 
           coef(result)['alpha']<0 ){
      #cat(paste0("\nattemp=",attempt))
      try(
        if(weighting){
          result<-twoCompFitRT_weighted(t=t.fit.shift,P=P.fit,t.interval,start=list(k_s=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1)),
                                        weighting=weighting,maxiter.search=1e3)
        }else{
          result<-twoCompFitRT(t=t.fit.shift,P=P.fit,t.interval,start=list(k_s=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1)),
                               maxiter.search=1e3,
                               k_ns=k_ns)
        },
        silent = TRUE
      )
      #cat("\n")
      #print(coef(result))
      #cat(paste0("\nalpha+beta=",as.numeric((coef(result)['alpha'] + coef(result)['beta']))))
      attempt = attempt + 1
    }
    
    if (!is.null(result)) {
      result=coef(result)[c(3,1,2)]
      if (as.numeric(result['k_s'])>as.numeric(result['k_ns'])){
        result=result[c(1,3,2)]
        result[1]=1-as.numeric(result[1])
        names(result)=c("alpha","k_s","k_ns")
      }
      
      # Calculate predicted/expected P from the fit
      P_pred = twoComponentPrediction(t.fit.shift, result['alpha'], result['k_s'], result['k_ns'])
      
      ## Calculate the fitting errors
      rss=RSS(P.fit, P_pred)
      aic=AIC(P.fit, P_pred, 3)
      bic=BIC(P.fit, P_pred, 3)
      #result=c(result[2:4],rss,aic,bic)
      result=c(result,rss,aic,bic)
      names(result)[4:6]=c("RSS","AIC","BIC")
      
      boot.2.fitRT=rbind(boot.2.fitRT,result)
      rownames(boot.2.fitRT)[dim(boot.2.fitRT)[1]]<-as.character(i-1)
      
      if (plot.fit||i<=3){
        ## Plot the data to be fitted in log-log scale
        par(mar = c(5,6,4,2) + 0.1)
        if (i==1){
          plot(t.plot,P[[i]][1:length(t.plot)],main="2-comp fit of original data",xlab="Time (s)",ylab=" ",
               cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
               bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
        }
        else{
          plot(t.plot,P[[i]][1:length(t.plot)],main=paste0("2-comp fit of bootstrapped data # ",i-1),xlab="Time (s)",ylab=" ",
               cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
               bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
        }
        
        title(ylab="Survival probability (1-CDF)",cex.lab=1.1,line=3.6)
        axis(2, at=at.y, labels=lab.y, las=1)
        axis(1, at=at.x, labels=lab.x, las=1)
        # Plot fitted curve
        p2_model = function(x){
          result['alpha']*exp(-result['k_s']*(x-min(t.fit))) + (1- result['alpha'])*exp(-result['k_ns']*(x-min(t.fit)))
        }
        curve(p2_model,add=T,col="red",lwd=2)
        
        ## Print parameters on the plot
        result.text=c(expression(italic(P(t) == alpha*e^-k[s]*''^t+(1-alpha)*e^-k[ns]*''^t)),
                      as.expression(bquote(italic('k'['s']==.(result['k_s'])))),
                      as.expression(bquote(italic('k'['ns']==.(result['k_ns'])))),
                      as.expression(bquote(italic(alpha==.(result['alpha'])))),
                      "  ",
                      as.expression(bquote(italic('RSS'==.(result['RSS'])))),
                      as.expression(bquote(italic('AIC'==.(result['AIC'])))),
                      as.expression(bquote(italic('BIC'==.(result['BIC'])))),
                      " "
        )
        legend("left",legend=result.text,pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
        par(font=1)
        legend("topright",legend = c("Data      ","Fit      "),
               pch=c(20,NA),lty=c(NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black"),
               col=c("black","red"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
        legend("bottomleft",legend = c(BootData$Name,paste("n = ",BootData$n,sep="")),
               text.col=c("grey60","grey60"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
        abline(v=cutoff, lty=3,  col='blue')
      }
      
    }else{
      cat("      This data set couldn't fit")
    }
    
    
    ####### 3-component fitting
    if (i==1){
      cat("\r","Original data","         3-component fitting")
    }else{
      cat("\r","Bootstrapped data # ",i-1,"      3-component fitting")
    }
    
    result = NULL
    attempt = 1
    maximum_attempts = 50
    while( (is.null(result) && attempt <= maximum_attempts) || 
           coef(result)['alpha']<0 || coef(result)['beta']<0 || 
           (coef(result)['alpha'] + coef(result)['beta']) >1){
      attempt = attempt + 1
      try(
        if(weighting){
          result<-threeCompFitRT_weighted(t=t.fit.shift,P=P.fit,t.interval,start=list(k_s=c(1/600,1/t.interval),k_m=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),beta=c(1e-3,1)),
                                          weighting = weighting,maxiter.search=1e3)
        }else{
          result<-threeCompFitRT(t=t.fit.shift,P=P.fit,t.interval,start=list(k_s=c(1/600,1/t.interval),k_m=c(1/600,1/t.interval),k_ns=c(1/600,1/t.interval),alpha=c(1e-3,1),beta=c(1e-3,1)),
                                 maxiter.search=1e3,
                                 k_ns=k_ns)
        },
        silent = TRUE
      )
      #cat("\n")
      #print(coef(result))
      #cat(paste0("\nalpha+beta=",as.numeric((coef(result)['alpha'] + coef(result)['beta']))))
      #cat(paste0("\nattemp=",attempt))
    } 
    
    if (is.null(result)) {
      cat("    This data set couldn't fit")
    }else{
      result=coef(result)[c(4,5,1,2,3)]
      
      if (as.numeric(result["k_s"])>as.numeric(result["k_m"])){
        result=result[c(2,1,4,3,5)]
        names(result)=c("alpha","beta","k_s","k_m","k_ns")
      }
      
      if (as.numeric(result["k_s"])>as.numeric(result["k_ns"])){
        result=result[c(1,2,5,4,3)]
        result[1]=1-as.numeric(result[1])-as.numeric(result[2])
        names(result)=c("alpha","beta","k_s","k_m","k_ns")
      }
      
      if (as.numeric(result["k_m"])>as.numeric(result["k_ns"])){
        result=result[c(1,2,3,5,4)]
        result[2]=1-as.numeric(result[1])-as.numeric(result[2])
        names(result)=c("alpha","beta","k_s","k_m","k_ns")
      }
      
      # Calculate predicted/expected P from the fit
      P_pred = threeComponentPrediction(t.fit.shift, result['alpha'], result['beta'], result['k_s'], result['k_m'], result['k_ns'])
      
      ## Calculate the fitting errors
      rss=RSS(P.fit, P_pred)
      aic=AIC(P.fit, P_pred, 5)
      bic=BIC(P.fit, P_pred, 5)
      result=c(result,rss,aic,bic)
      names(result)[6:8]=c("RSS","AIC","BIC")
      
      boot.3.fitRT=rbind(boot.3.fitRT,result)
      rownames(boot.3.fitRT)[dim(boot.3.fitRT)[1]]<-as.character(i-1)
      
      if (plot.fit||i<=3){
        ## Plot the data to be fitted in log-log scale
        par(mar = c(5,6,4,2) + 0.1)
        if (i==1){
          plot(t.plot,P[[i]][1:length(t.plot)],main="3-comp fit of original data",xlab="Time (s)",ylab=" ",
               cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
               bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
        }
        else{
          plot(t.plot,P[[i]][1:length(t.plot)],main=paste0("3-comp fit of bootstrapped data # ",i-1),xlab="Time (s)",ylab=" ",
               cex.main=1.2,xlim=c(0.1,x.max),ylim=c(y.min,1.28),cex.axis=1.5,cex.lab=1.1,pch=20,cex=0.8,
               bty="n",xaxs="i",yaxs="i",log="xy",xaxt="n",yaxt="n")
        }
        
        title(ylab="Survival probability (1-CDF)",cex.lab=1.1,line=3.6)
        axis(2, at=at.y, labels=lab.y, las=1)
        axis(1, at=at.x, labels=lab.x, las=1)
        
        # Plot fitted curve
        p3_model = function(x){
          result['alpha']*exp(-result['k_s']*(x-min(t.fit))) + 
            result['beta']*exp(-result['k_m']*(x-min(t.fit))) + 
            (1- result['alpha']-result['beta'])*exp(-result['k_ns']*(x-min(t.fit)))
        }
        curve(p3_model,add=T,col="purple",lwd=2)
        
        ## Print parameters on the plot
        result.text=c(expression(italic(P(t) == alpha*e^-k[s]*''^t+beta*e^-k[m]*''^t+(1-alpha-beta)*e^-k[ns]*''^t)),
                      as.expression(bquote(italic('k'['s']==.(result['k_s'])))),
                      as.expression(bquote(italic('k'['m']==.(result['k_m'])))),
                      as.expression(bquote(italic('k'['ns']==.(result['k_ns'])))),
                      as.expression(bquote(italic(alpha==.(result['alpha'])))),
                      as.expression(bquote(italic(beta==.(result['beta'])))),
                      "  ",
                      as.expression(bquote(italic('RSS'==.(result['RSS'])))),
                      as.expression(bquote(italic('AIC'==.(result['AIC'])))),
                      as.expression(bquote(italic('BIC'==.(result['BIC'])))),
                      " "
        )
        legend("left",legend=result.text,pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
        par(font=1)
        legend("topright",legend = c("Data      ","Fit      "),
               pch=c(20,NA),lty=c(NA,1),seg.len=0.6,lwd = 1.5,text.col=c("black","black"),
               col=c("black","purple"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
        legend("bottomleft",legend = c(BootData$Name,paste("n = ",BootData$n,sep="")),
               text.col=c("grey60","grey60"),bty="n",y.intersp = 0.8,x.intersp = 0.5)
        abline(v=cutoff, lty=3, col='blue')
      }
    }
    flush.console()
  }
  
  
  #rownames(boot.2.fitRT)<-c(0:(dim(boot.2.fitRT)[1]-1))
  
  boot.2.fitRT.df=as.data.frame(boot.2.fitRT)
  boot.2.fitRT.filter=boot.2.fitRT.df[which(boot.2.fitRT.df[,2]>0),]
  
  #rownames(boot.3.fitRT)<-c(0:(dim(boot.3.fitRT)[1]-1))
  
  boot.3.fitRT.df=as.data.frame(boot.3.fitRT)
  boot.3.fitRT.filter=boot.3.fitRT.df[which(boot.3.fitRT.df[,1]>0),]
  boot.3.fitRT.filter=boot.3.fitRT.filter[which(boot.3.fitRT.filter[,2]>0),]
  boot.3.fitRT.filter=boot.3.fitRT.filter[which((boot.3.fitRT.filter[,1]+boot.3.fitRT.filter[,2])<=1),]
  boot.3.fitRT.filter=boot.3.fitRT.filter[which(boot.3.fitRT.filter[,3]>0),]
  
  ## Plot results
  plot(rownames(boot.2.fitRT.filter),boot.2.fitRT.filter$k_ns,type='p',main="2-component fitting",
       xlab = "Data #", ylab = "k",ylim = c(0,max(boot.2.fitRT.filter$k_ns)),
       las=1, cex.axis=0.8,xaxt="n",pch=16,col="blue")
  points(rownames(boot.2.fitRT.filter),boot.2.fitRT.filter$k_s,pch=16,col="orange")
  axis(1, at = seq(0, (R-1), by = 5), las=1)
  if(weighting){
    legend("topright",legend=c(as.expression(bquote(italic('k'['slow']))),as.expression(bquote(italic('k'['fast']))),"Weighted"),pch=c(16,16,NA),col=c("orange","blue","black"),y.intersp = 0.8,bty = "n",cex=1)
  }else{
    legend("topright",legend=c(as.expression(bquote(italic('k'['slow']))),as.expression(bquote(italic('k'['fast'])))),pch=c(16,16),col=c("orange","blue"),y.intersp = 0.8,bty = "n",cex=1)
  }
  
  plot(rownames(boot.3.fitRT.filter),boot.3.fitRT.filter$k_ns,type='p',main="3-component fitting",
       xlab = "Data #", ylab = "k",ylim = c(0,max(boot.3.fitRT.filter$k_ns)),
       las=1, cex.axis=0.8,xaxt="n",pch=16,col="blue")
  points(rownames(boot.3.fitRT.filter),boot.3.fitRT.filter$k_s,pch=16,col="orange")
  points(rownames(boot.3.fitRT.filter),boot.3.fitRT.filter$k_m,pch=16,col="grey")
  axis(1, at = seq(0, (R-1), by = 5), las=1)
  if(weighting){
    legend("topright",legend=c(as.expression(bquote(italic('k'['slow']))),as.expression(bquote(italic('k'['medium']))),as.expression(bquote(italic('k'['fast']))),"Weighted"),pch=c(16,16,16,NA),col=c("orange","grey","blue","black"),y.intersp = 0.8,bty = "n",cex=1)
  }else{
    legend("topright",legend=c(as.expression(bquote(italic('k'['slow']))),as.expression(bquote(italic('k'['medium']))),as.expression(bquote(italic('k'['fast'])))),pch=c(16,16,16),col=c("orange","grey","blue"),y.intersp = 0.8,bty = "n",cex=1)
  }
  
  ## Plot histogram of k_s
  hist<-hist(as.numeric(boot.2.fitRT.filter[,2]),main = "Histogram of 2-component fitting", 
             xlab = as.expression(bquote(italic('k'['slow']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  title(main=BootData$Name,line=0.2)
  legend_text=c(as.expression(bquote('Mean of k'['slow'] ==.(mean(as.numeric(boot.2.fitRT.filter[,2]))))),
                as.expression(bquote('SD of k'['slow'] ==.(sd(as.numeric(boot.2.fitRT.filter[,2]))))),
                as.expression(bquote('n'==.(length(boot.2.fitRT.filter[,2])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  if(weighting){
    legend("topright",legend="Weighted",pch=NULL,y.intersp = 0.8,bty = "n",cex=1)
  }
  ## Plot histogram of alpha
  hist<-hist(as.numeric(boot.2.fitRT.filter[,1]),main = "Histogram of 2-component fitting", 
             xlab = as.expression(bquote(italic('F'['slow']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  title(main=BootData$Name,line=0.2)
  legend_text=c(as.expression(bquote('Mean of F'['slow'] ==.(mean(as.numeric(boot.2.fitRT.filter[,1]))))),
                as.expression(bquote('SD of F'['slow'] ==.(sd(as.numeric(boot.2.fitRT.filter[,1]))))),
                as.expression(bquote('n'==.(length(boot.2.fitRT.filter[,1])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  if(weighting){
    legend("topright",legend="Weighted",pch=NULL,y.intersp = 0.8,bty = "n",cex=1)
  }
  
  hist<-hist(as.numeric(boot.3.fitRT.filter[,3]),main = "Histogram of 3-component fitting", 
             xlab = as.expression(bquote(italic('k'['slow']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  title(main=BootData$Name,line=0.2)
  legend_text=c(as.expression(bquote('Mean of k'['slow'] ==.(mean(as.numeric(boot.3.fitRT.filter[,3]))))),
                as.expression(bquote('SD of k'['slow'] ==.(sd(as.numeric(boot.3.fitRT.filter[,3]))))),
                as.expression(bquote('n'==.(length(boot.3.fitRT.filter[,3])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  if(weighting){
    legend("topright",legend="Weighted",pch=NULL,y.intersp = 0.8,bty = "n",cex=1)
  }
  
  hist<-hist(as.numeric(boot.3.fitRT.filter[,1]),main = "Histogram of 3-component fitting", 
             xlab = as.expression(bquote(italic('F'['slow']))),xaxt="n",col="grey")
  axis(1,hist$breaks,labels=hist$breaks)
  title(main=BootData$Name,line=0.2)
  legend_text=c(as.expression(bquote('Mean of F'['slow'] ==.(mean(as.numeric(boot.3.fitRT.filter[,1]))))),
                as.expression(bquote('SD of F'['slow'] ==.(sd(as.numeric(boot.3.fitRT.filter[,1]))))),
                as.expression(bquote('n'==.(length(boot.3.fitRT.filter[,1])))))
  legend("topleft",legend=legend_text,
         pch=NULL,y.intersp=0.8,x.intersp=0.3,bty="n",cex=1)
  if(weighting){
    legend("topright",legend="Weighted",pch=NULL,y.intersp = 0.8,bty = "n",cex=1)
  }
  
  ## Plot RSS
  options(scipen=10)
  #plot(rownames(boot.2.fitRT.filter),boot.2.fitRT.filter$RSS,type='p',main="RSS of 2-component fitting",
  #     xlab = "Data #", ylab = "RSS",las=1, cex.axis=0.8,xaxt="n")
  plot(rownames(boot.2.fitRT.filter),boot.2.fitRT.filter$RSS,type='p',main="Residual Sum-of-Squares",
       xlab = "Data #", ylab = "RSS",ylim = c(0,max(boot.2.fitRT.filter$RSS)+max(boot.3.fitRT.filter$RSS)),
       las=1, cex.axis=0.8,xaxt="n",pch=16,col="red")
  points(rownames(boot.3.fitRT.filter),boot.3.fitRT.filter$RSS,pch=16,col="purple")
  axis(1, at = seq(0, (R-1), by = 5), las=1)
  if(weighting){
    legend("topright",legend=c("2-comp","3-comp","Weighted"),pch=c(16,16,NA),col=c("red","purple","black"),y.intersp = 0.8,bty = "n",cex=1)
  }else{
    legend("topright",legend=c("2-comp","3-comp"),pch=c(16,16),col=c("red","purple"),y.intersp = 0.8,bty = "n",cex=1)
  }
  
  #plot(rownames(boot.3.fitRT.filter),boot.3.fitRT.filter$RSS,type='p',main="RSS of 3-component fitting",
  #     xlab = "Data #", ylab = "RSS",las=1, cex.axis=0.8,xaxt="n")
  #axis(1, at = seq(0, (R-1), by = 5), las=1)
  #if(weighting){
  #  legend("topright",legend="Weighted",pch=NULL,y.intersp = 0.8,bty = "n",cex=1)
  #}
  
  plot(rownames(boot.2.fitRT.filter),boot.2.fitRT.filter$alpha,type='p',main="Fractions",
       xlab = "Data #", ylab = "Fraction",ylim = c(0,1),
       las=1, cex.axis=0.8,xaxt="n",pch=16,col="magenta")
  points(rownames(boot.3.fitRT.filter),boot.3.fitRT.filter$alpha,pch=16,col="green")
  points(rownames(boot.3.fitRT.filter),boot.3.fitRT.filter$beta,pch=16,col="darkgreen")
  axis(1, at = seq(0, (R-1), by = 5), las=1)
  if(weighting){
    legend("topright",legend=c(as.expression(bquote(italic('alpha (2-comp)'))),
                               as.expression(bquote(italic('alpha (3-comp)'))),
                               as.expression(bquote(italic('beta (3-comp)'))),
                               "Weighted"),
           pch=c(16,16,16,NA),col=c("magenta","green","darkgreen","black"),y.intersp = 0.8,bty = "n",cex=1)
  }else{
    legend("topright",legend=c(as.expression(bquote(italic('alpha (2-comp)'))),
                               as.expression(bquote(italic('alpha (3-comp)'))),
                               as.expression(bquote(italic('beta (3-comp)')))),
           pch=c(16,16,16),col=c("magenta","green","darkgreen"),y.intersp = 0.8,bty = "n",cex=1)
  }
  
  plot(boot.3.fitRT.filter$k_s[order(boot.3.fitRT.filter$k_s)],
       boot.3.fitRT.filter$k_m[order(boot.3.fitRT.filter$k_s)],
       type='p',main="3-component fitting",
       xlab = as.expression(bquote(italic('k'['slow']))), ylab = as.expression(bquote(italic('k'['medium']))),
       las=1, cex.axis=0.8,pch=16,col="orange")
  if(weighting){
    legend("topright",legend=c(as.expression(bquote(italic('k'['slow']*' vs k'['medium']))),
                               "Weighted"),
           pch=c(16,NA),col=c("orange","black"),y.intersp = 0.8,bty = "n",cex=1)
  }else{
    legend("topleft",legend=as.expression(bquote(italic('k'['slow']*' vs k'['medium']))),
           pch=16,col="orange",y.intersp = 0.8,bty = "n",cex=1)
  }
  plot(boot.3.fitRT.filter$alpha[order(boot.3.fitRT.filter$alpha)],
       boot.3.fitRT.filter$beta[order(boot.3.fitRT.filter$alpha)],
       type='p',main="3-component fitting",
       xlab = as.expression(bquote(italic('alpha'))), ylab = as.expression(bquote(italic('beta'))),
       las=1, cex.axis=0.8,pch=16,col="green")
  if(weighting){
    legend("topright",legend=c(as.expression(bquote(italic('alpha vs beta'))),
                               "Weighted"),
           pch=c(16,NA),col=c("green","black"),y.intersp = 0.8,bty = "n",cex=1)
  }else{
    legend("topright",legend=as.expression(bquote(italic('alpha vs beta'))),
           pch=16,col="green",y.intersp = 0.8,bty = "n",cex=1)
  }
  
  
  dev.off()
  
  if(output){
    boot.2.fitRT.filter.2 <- apply(boot.2.fitRT.filter,2,as.numeric)
    filename<-paste("Bootstrapped data 2-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".csv",sep="")
    write.table(boot.2.fitRT.filter.2, filename, append= F, sep=",",  col.names=NA,row.names = row.names(boot.2.fitRT.filter))
    boot.3.fitRT.filter.2 <- apply(boot.3.fitRT.filter,2,as.numeric)
    filename<-paste("Bootstrapped data 3-component fitting - ", BootData$Name," - ",format(Sys.time(),"%Y%m%d_%H%M%S"),".csv",sep="")
    write.table(boot.3.fitRT.filter.2, filename, append= F, sep=",",  col.names=NA,row.names = row.names(boot.3.fitRT.filter))
  }
  
  cat("\n\nPDF output in working directory")
  return(invisible(list("2-component fitting"=boot.2.fitRT.filter,"3-component fitting"=boot.3.fitRT.filter)))
  
}

